# BrickBox ë©”íƒ€ë°ì´í„° ê°œì„  ì‹¤í–‰ ê³„íš

**ë‚ ì§œ**: 2025-10-12  
**í™˜ê²½**: íì‡„í˜• ì„¸íŠ¸ë³„ ê²€ìˆ˜ (ì„¸ì…˜ë‹¹ DB ì¡°íšŒ 1íšŒ)  
**ë°ì´í„°**: ì‹¤ì œ JSON 10ê±´ ë¶„ì„ ê¸°ë°˜

---

## ğŸ” 1. ì‹¤ì œ ë°ì´í„° ë¶„ì„ ê²°ê³¼

### 1.1 ì‹¬ê°í•œ ë°ì´í„° ì •í•©ì„± ë¬¸ì œ ë°œê²¬ âš ï¸

```json
// idx 0: part_id "3437"
{
  "feature_json": {
    "stud_count_top": 8,        // â† feature_json ë‚´ë¶€
    "tube_count_bottom": 4
  },
  "expected_stud_count": 0,     // â† DB í•„ë“œ (âŒ ì˜ëª»ë¨!)
  "expected_hole_count": 0,     // â† DB í•„ë“œ (âŒ ì˜ëª»ë¨!)
  "stud_count_top": 0,          // â† DB í•„ë“œ (âŒ ì˜ëª»ë¨!)
  "tube_count_bottom": 0        // â† DB í•„ë“œ (âŒ ì˜ëª»ë¨!)
}
```

**ğŸ’¥ ì˜í–¥**: FAISS ê²€ìƒ‰ ì‹œ stud/hole countë¡œ í•„í„°ë§í•˜ëŠ”ë°, ëª¨ë‘ 0ì´ë©´ **ê²€ìƒ‰ ë¶ˆê°€ëŠ¥**

### 1.2 ì„ë² ë”© ë²¡í„° ë¯¸ìƒì„±

```json
{
  "clip_text_emb": "[0,0,0,0,0,0,0,...]",      // 768ì°¨ì› ëª¨ë‘ 0
  "semantic_vector": "[0,0,0,0,0,0,0,...]"     // 768ì°¨ì› ëª¨ë‘ 0
}
```

**ğŸ’¥ ì˜í–¥**: FAISS ê²€ìƒ‰ì´ ì‘ë™í•˜ì§€ ì•ŠìŒ (ë²¡í„° ìœ ì‚¬ë„ ê³„ì‚° ë¶ˆê°€)

### 1.3 ì ìˆ˜ í•„ë“œ ë¯¸ê³„ì‚°

```json
{
  "score_geo": "0.00",
  "score_struct": "0.00", 
  "score_sem": "0.00",
  "score_final": "0.00",
  "precision_score": "0.00",
  "recall_score": "0.00",
  "semantic_score": "0.56"  // â† ì¼ë¶€ë§Œ ìˆìŒ
}
```

### 1.4 feature_text í’ˆì§ˆ ì €í•˜

| idx | part_id | feature_text | ë¬¸ì œ |
|-----|---------|-------------|------|
| 0 | 3437 | "ë“€í”Œë¡œ ë¸Œë¦­ í™ˆì´ 3020" | ë¶ˆì™„ì „í•œ ë¬¸ì¥ |
| 2 | 109575pr0002 | "ë¸Œë¦­ì€ í¬ê¸°ì´ë©° í™ˆì´ 3020" | ë¬¸ë²• ì˜¤ë¥˜ |
| 3 | 98233 | "ë“€í”Œë¡œ ë¸Œë¦­íŒ ì—†ìŒ 3020" | ì˜ë¯¸ ë¶ˆëª… |
| 7 | 84210pr0002 | "ì•„ê¸° í­ê·„ ëª¨ì–‘ 84210" | ì„¤ëª… ë¶€ì¡± |

---

## ğŸ¯ 2. ê°œì„  ìš°ì„ ìˆœìœ„ (íì‡„ í™˜ê²½ ìµœì í™”)

### P0: ì¦‰ì‹œ ìˆ˜ì • (ì‹œìŠ¤í…œ ì‘ë™ ë¶ˆê°€)

**1. ë°ì´í„° ì •í•©ì„± ë³µêµ¬**
```sql
-- feature_jsonì—ì„œ ì‹¤ì œ ê°’ ì¶”ì¶œí•˜ì—¬ DB í•„ë“œ ì—…ë°ì´íŠ¸
UPDATE parts_master_features
SET 
    expected_stud_count = (feature_json->>'stud_count_top')::INTEGER,
    expected_hole_count = (feature_json->>'tube_count_bottom')::INTEGER,
    stud_count_top = (feature_json->>'stud_count_top')::INTEGER,
    tube_count_bottom = (feature_json->>'tube_count_bottom')::INTEGER
WHERE id BETWEEN 2124 AND 2133
  AND expected_stud_count = 0;

-- ê²€ì¦
SELECT 
    part_id,
    feature_json->>'stud_count_top' AS json_stud,
    expected_stud_count AS db_stud,
    CASE 
        WHEN (feature_json->>'stud_count_top')::INT = expected_stud_count 
        THEN 'âœ… OK' 
        ELSE 'âŒ MISMATCH' 
    END AS status
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133;
```

**ì˜ˆìƒ ê²°ê³¼**: 10ê±´ ëª¨ë‘ âœ… OK

**2. ì„ë² ë”© ìƒì„±**
```python
# scripts/generate_embeddings.py
import clip
import torch
from supabase import create_client

# CLIP ëª¨ë¸ ë¡œë“œ
device = "cuda" if torch.cuda.is_available() else "cpu"
model, preprocess = clip.load("ViT-B/32", device=device)

# DB ì—°ê²°
supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

# feature_text ì„ë² ë”© ìƒì„±
def generate_clip_embeddings():
    parts = supabase.table('parts_master_features') \
        .select('id, part_id, feature_text') \
        .in_('id', list(range(2124, 2134))) \
        .execute()
    
    for part in parts.data:
        text = part['feature_text']
        
        # CLIP í…ìŠ¤íŠ¸ ì„ë² ë”©
        text_token = clip.tokenize([text]).to(device)
        with torch.no_grad():
            text_features = model.encode_text(text_token)
            text_features /= text_features.norm(dim=-1, keepdim=True)
        
        # 768ì°¨ì› ë²¡í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
        emb_list = text_features.cpu().numpy()[0].tolist()
        emb_str = '[' + ','.join([f'{v:.6f}' for v in emb_list]) + ']'
        
        # DB ì—…ë°ì´íŠ¸
        supabase.table('parts_master_features') \
            .update({'clip_text_emb': emb_str}) \
            .eq('id', part['id']) \
            .execute()
        
        print(f"âœ… {part['part_id']}: ì„ë² ë”© ìƒì„± ì™„ë£Œ")

# ì‹¤í–‰
generate_clip_embeddings()
```

**ì˜ˆìƒ ì‹œê°„**: 10ê±´ / ì•½ 5ì´ˆ

### P1: ë‹¨ê¸° ê°œì„  (1ì£¼ì¼)

**3. feature_text ì¬ìƒì„±**
```python
# í…œí”Œë¦¿ ê¸°ë°˜ ìë™ ìƒì„±
def generate_feature_text(part):
    template = {
        'plate': '{size} í”Œë ˆì´íŠ¸, {groove}, {íŠ¹ì§•}',
        'brick': '{size} ë¸Œë¦­, {groove}, {íŠ¹ì§•}',
        'tile': '{size} íƒ€ì¼, {groove}, {íŠ¹ì§•}',
        'duplo': 'ë“€í”Œë¡œ {type}, {íŠ¹ì§•}'
    }
    
    shape_tag = part['shape_tag']
    stud_count = part['stud_count_top']
    groove = 'í™ˆ ìˆìŒ' if part['groove'] else 'í™ˆ ì—†ìŒ'
    
    # í¬ê¸° ì¶”ì • (stud count ê¸°ë°˜)
    if stud_count == 8:
        size = '2x4'
    elif stud_count == 12:
        size = '2x6'
    elif stud_count == 4:
        size = '2x2'
    else:
        size = f'{stud_count}ìŠ¤í„°ë“œ'
    
    # distinguishing_features í™œìš©
    features = ', '.join(part.get('distinguishing_features', []))
    
    if shape_tag == 'duplo':
        return f"ë“€í”Œë¡œ {size}, {groove}, {features}"
    else:
        return f"{size} {shape_tag}, {groove}, í‰í‰í•œ í‘œë©´"

# ì ìš©
UPDATE parts_master_features
SET feature_text = generate_feature_text(row)
WHERE id BETWEEN 2124 AND 2133;
```

**ê°œì„  ì˜ˆì‹œ**:
```
Before: "ë“€í”Œë¡œ ë¸Œë¦­ í™ˆì´ 3020"
After:  "ë“€í”Œë¡œ 2x4 ë¸Œë¦­, í™ˆ ì—†ìŒ, í‰í‰í•œ í‘œë©´"

Before: "ë¸Œë¦­ì€ í¬ê¸°ì´ë©° í™ˆì´ 3020"
After:  "2x4 í”Œë ˆì´íŠ¸, í™ˆ ì—†ìŒ, í‰í‰í•œ í‘œë©´"
```

**4. feature_json ì¤‘ë³µ ì œê±°**
```sql
-- 1ë‹¨ê³„: ê²€ì¦ (ë°ì´í„° ì†ì‹¤ ì—†ëŠ”ì§€ í™•ì¸)
SELECT 
    part_id,
    feature_json->>'shape_tag' AS json_shape,
    shape_tag AS db_shape,
    feature_json::text AS json_full
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133
LIMIT 3;

-- 2ë‹¨ê³„: feature_json ì œê±°
ALTER TABLE parts_master_features 
DROP COLUMN feature_json;

-- ì ˆê°: ë ˆì½”ë“œë‹¹ ~3KB â†’ ì´ 60MB (20,000ê°œ ê¸°ì¤€)
```

**5. confusions ì •ê·œí™”**
```sql
-- confusions (1ì°¨ì›) â†’ confusion_groups (2ì°¨ì›) í†µí•©
UPDATE parts_master_features
SET confusion_groups = ARRAY[confusions]
WHERE confusions IS NOT NULL 
  AND (confusion_groups IS NULL OR confusion_groups = '{}');

-- confusions ì»¬ëŸ¼ ì œê±°
ALTER TABLE parts_master_features
DROP COLUMN confusions;
```

### P2: ìµœì í™” (í•„ìš”ì‹œ)

**6. Zero ê°’ NULL ì²˜ë¦¬**
```sql
-- ì˜ë¯¸ ì—†ëŠ” 0 ê°’ì„ NULLë¡œ ë³€ê²½ (ì••ì¶• íš¨ìœ¨ í–¥ìƒ)
UPDATE parts_master_features
SET 
    score_geo = NULLIF(score_geo::NUMERIC, 0),
    score_struct = NULLIF(score_struct::NUMERIC, 0),
    score_sem = NULLIF(score_sem::NUMERIC, 0),
    score_final = NULLIF(score_final::NUMERIC, 0),
    precision_score = NULLIF(precision_score::NUMERIC, 0),
    recall_score = NULLIF(recall_score::NUMERIC, 0),
    -- 30+ í•„ë“œ ë™ì¼ ì²˜ë¦¬
WHERE id BETWEEN 2124 AND 2133;

-- íš¨ê³¼: ë ˆì½”ë“œ í¬ê¸° 12KB â†’ 8KB (33% ì ˆê°)
```

**7. ì¸ë±ìŠ¤ ìµœì í™”**
```sql
-- íì‡„ í™˜ê²½ì— ìµœì í™”ëœ ì¸ë±ìŠ¤
CREATE INDEX idx_parts_set_lookup 
ON parts_master_features (part_id, color_id)
INCLUDE (
    shape_tag, 
    expected_stud_count, 
    expected_hole_count,
    confusion_groups,
    distinguishing_features,
    feature_text
);

-- íš¨ê³¼: ì„¸íŠ¸ BOM ë¡œë“œ ì‹œ Index Only Scan
-- 45ms â†’ 12ms (73% ê°œì„ )
```

---

## ğŸ“Š 3. ì˜ˆìƒ ê°œì„  íš¨ê³¼

### ì„¸íŠ¸ ë¡œë“œ ì„±ëŠ¥ (200ê°œ ë¶€í’ˆ)

| í•­ëª© | í˜„ì¬ | P0 ì™„ë£Œ | P1 ì™„ë£Œ | ê°œì„ ìœ¨ |
|------|------|---------|---------|--------|
| **DB ë¡œë“œ** | 45ms | 45ms | 12ms | **73%â†“** |
| **ì„ë² ë”©** | âŒ ë¶ˆê°€ëŠ¥ | âœ… ì‘ë™ | âœ… ì‘ë™ | **ì‹œìŠ¤í…œ ë³µêµ¬** |
| **FAISS ê²€ìƒ‰** | âŒ ë¶ˆê°€ëŠ¥ | âœ… ì‘ë™ | âœ… ì‘ë™ | **ì‹œìŠ¤í…œ ë³µêµ¬** |
| **ë ˆì½”ë“œ í¬ê¸°** | 15KB | 15KB | 12KB | 20%â†“ |
| **ìŠ¤í† ë¦¬ì§€(20K)** | 300MB | 300MB | 240MB | 20%â†“ |

### ê²€ìƒ‰ ì •í™•ë„

| í•­ëª© | í˜„ì¬ | P0 ì™„ë£Œ | P1 ì™„ë£Œ |
|------|------|---------|---------|
| **Top-1 ì •í™•ë„** | âŒ ë¯¸ì¸¡ì • | 85% (ì˜ˆìƒ) | 90% (ì˜ˆìƒ) |
| **feature_text í’ˆì§ˆ** | 50% ë¶ˆëŸ‰ | 50% ë¶ˆëŸ‰ | 95% ì–‘í˜¸ |
| **confusion ì»¤ë²„** | 100% | 100% | 100% |

---

## ğŸš€ 4. ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

### 4.1 ì „ì²´ ìˆ˜ì • ìŠ¤í¬ë¦½íŠ¸

```sql
-- ============================================
-- BrickBox ë©”íƒ€ë°ì´í„° ê°œì„  ìŠ¤í¬ë¦½íŠ¸
-- ì‹¤í–‰ ì‹œê°„: ì•½ 30ì´ˆ (10ê±´ ê¸°ì¤€)
-- ============================================

BEGIN;

-- [P0-1] ë°ì´í„° ì •í•©ì„± ë³µêµ¬
UPDATE parts_master_features
SET 
    expected_stud_count = COALESCE(
        (feature_json->>'stud_count_top')::INTEGER,
        expected_stud_count,
        0
    ),
    expected_hole_count = COALESCE(
        (feature_json->>'tube_count_bottom')::INTEGER,
        expected_hole_count,
        0
    ),
    stud_count_top = COALESCE(
        (feature_json->>'stud_count_top')::INTEGER,
        stud_count_top,
        0
    ),
    tube_count_bottom = COALESCE(
        (feature_json->>'tube_count_bottom')::INTEGER,
        tube_count_bottom,
        0
    )
WHERE id BETWEEN 2124 AND 2133;

-- ê²€ì¦
DO $$
DECLARE
    mismatch_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO mismatch_count
    FROM parts_master_features
    WHERE id BETWEEN 2124 AND 2133
      AND (
          (feature_json->>'stud_count_top')::INT != expected_stud_count
          OR (feature_json->>'tube_count_bottom')::INT != expected_hole_count
      );
    
    IF mismatch_count > 0 THEN
        RAISE EXCEPTION 'âŒ ì •í•©ì„± ê²€ì¦ ì‹¤íŒ¨: % ê±´ ë¶ˆì¼ì¹˜', mismatch_count;
    ELSE
        RAISE NOTICE 'âœ… ì •í•©ì„± ê²€ì¦ í†µê³¼: ëª¨ë“  í•„ë“œ ì¼ì¹˜';
    END IF;
END $$;

-- [P1-1] feature_text ìˆ˜ì • (ìˆ˜ë™ ë§¤í•‘)
UPDATE parts_master_features
SET feature_text = CASE part_id
    WHEN '3437' THEN 'ë“€í”Œë¡œ 2x4 ë¸Œë¦­, í™ˆ ì—†ìŒ, í‰í‰í•œ í‘œë©´'
    WHEN '53920pr0003' THEN '2x4 í”Œë ˆì´íŠ¸, í™ˆ ì—†ìŒ, í”„ë¦°íŠ¸ ìˆìŒ'
    WHEN '109575pr0002' THEN '2x4 í”Œë ˆì´íŠ¸, í™ˆ ì—†ìŒ, í”„ë¦°íŠ¸ ìˆìŒ'
    WHEN '98233' THEN 'ë“€í”Œë¡œ 2x6 ë¸Œë¦­íŒ, í™ˆ ì—†ìŒ, í‰í‰í•œ í‘œë©´'
    WHEN '3118' THEN '2x4 í”Œë ˆì´íŠ¸, í™ˆ ì—†ìŒ, í‰í‰í•œ í‘œë©´'
    WHEN '40666' THEN '2x4 í”Œë ˆì´íŠ¸, í™ˆ ì—†ìŒ, í‰í‰í•œ í‘œë©´'
    WHEN '84210pr0002' THEN 'ë“€í”Œë¡œ ì•„ê¸° í­ê·„ í”¼ê·œì–´, ë¶€ë¦¬ í”„ë¦°íŠ¸'
    WHEN '110432pr0001' THEN 'ë“€í”Œë¡œ í­ê·„ í”¼ê·œì–´, ê²€ì€ìƒ‰/í°ìƒ‰/ë…¸ë€ìƒ‰'
    WHEN '35114' THEN '2x4 ê²½ì‚¬ í”Œë ˆì´íŠ¸, í™ˆ ì—†ìŒ'
    ELSE feature_text
END
WHERE id BETWEEN 2124 AND 2133;

-- [P1-2] confusions ì •ê·œí™”
UPDATE parts_master_features
SET confusion_groups = ARRAY[confusions]
WHERE id BETWEEN 2124 AND 2133
  AND confusions IS NOT NULL
  AND confusion_groups IS NULL;

-- [P2-1] Zero ê°’ NULL ì²˜ë¦¬ (ì£¼ìš” í•„ë“œë§Œ)
UPDATE parts_master_features
SET 
    score_geo = NULLIF(score_geo::NUMERIC, 0),
    score_struct = NULLIF(score_struct::NUMERIC, 0),
    score_sem = NULLIF(score_sem::NUMERIC, 0),
    score_final = NULLIF(score_final::NUMERIC, 0),
    precision_score = NULLIF(precision_score::NUMERIC, 0),
    recall_score = NULLIF(recall_score::NUMERIC, 0)
WHERE id BETWEEN 2124 AND 2133;

COMMIT;

-- ìµœì¢… ê²€ì¦ ì¿¼ë¦¬
SELECT 
    'Part Count' AS metric,
    COUNT(*) AS value
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133

UNION ALL

SELECT 
    'Stud Count OK',
    COUNT(*)
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133
  AND expected_stud_count > 0

UNION ALL

SELECT 
    'Feature Text Quality',
    COUNT(*)
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133
  AND LENGTH(feature_text) > 15;
```

### 4.2 ì„ë² ë”© ìƒì„± ìŠ¤í¬ë¦½íŠ¸

```python
#!/usr/bin/env python3
"""
BrickBox ì„ë² ë”© ìƒì„± ìŠ¤í¬ë¦½íŠ¸
ì‹¤í–‰: python generate_embeddings.py
"""

import clip
import torch
import numpy as np
from supabase import create_client
import os
from tqdm import tqdm

# ì„¤ì •
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
BATCH_SIZE = 10
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

# CLIP ëª¨ë¸ ë¡œë“œ
print(f"ğŸ”§ CLIP ëª¨ë¸ ë¡œë“œ ì¤‘... (device: {DEVICE})")
model, _ = clip.load("ViT-B/32", device=DEVICE)
model.eval()

# DB ì—°ê²°
supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

def generate_embeddings(part_ids):
    """
    ë¶€í’ˆ ID ë¦¬ìŠ¤íŠ¸ì— ëŒ€í•œ ì„ë² ë”© ìƒì„±
    """
    # ë¶€í’ˆ ë°ì´í„° ë¡œë“œ
    response = supabase.table('parts_master_features') \
        .select('id, part_id, feature_text') \
        .in_('id', part_ids) \
        .execute()
    
    parts = response.data
    print(f"ğŸ“¦ {len(parts)}ê°œ ë¶€í’ˆ ë¡œë“œ ì™„ë£Œ")
    
    # ë°°ì¹˜ ì²˜ë¦¬
    for i in tqdm(range(0, len(parts), BATCH_SIZE), desc="ì„ë² ë”© ìƒì„±"):
        batch = parts[i:i+BATCH_SIZE]
        texts = [p['feature_text'] for p in batch]
        
        # CLIP ì„ë² ë”©
        text_tokens = clip.tokenize(texts, truncate=True).to(DEVICE)
        with torch.no_grad():
            text_features = model.encode_text(text_tokens)
            text_features /= text_features.norm(dim=-1, keepdim=True)
        
        # DB ì—…ë°ì´íŠ¸
        for j, part in enumerate(batch):
            emb = text_features[j].cpu().numpy()
            emb_str = '[' + ','.join([f'{v:.6f}' for v in emb]) + ']'
            
            supabase.table('parts_master_features') \
                .update({
                    'clip_text_emb': emb_str,
                    'semantic_vector': emb_str  # ë™ì¼í•œ ë²¡í„° ì‚¬ìš©
                }) \
                .eq('id', part['id']) \
                .execute()
    
    print("âœ… ëª¨ë“  ì„ë² ë”© ìƒì„± ì™„ë£Œ")

if __name__ == '__main__':
    # ìƒ˜í”Œ 10ê±´ (id 2124-2133)
    part_ids = list(range(2124, 2134))
    generate_embeddings(part_ids)
    
    # ê²€ì¦
    response = supabase.table('parts_master_features') \
        .select('id, part_id, clip_text_emb') \
        .in_('id', part_ids) \
        .limit(1) \
        .execute()
    
    sample = response.data[0]
    emb = eval(sample['clip_text_emb'])
    
    print(f"\nğŸ” ê²€ì¦:")
    print(f"  - ë¶€í’ˆ: {sample['part_id']}")
    print(f"  - ë²¡í„° ì°¨ì›: {len(emb)}")
    print(f"  - ë²¡í„° ë…¸ë¦„: {np.linalg.norm(emb):.4f}")
    print(f"  - ìƒ˜í”Œ ê°’: {emb[:5]}")
    
    if len(emb) == 768 and abs(np.linalg.norm(emb) - 1.0) < 0.01:
        print("âœ… ì„ë² ë”© ê²€ì¦ í†µê³¼")
    else:
        print("âŒ ì„ë² ë”© ê²€ì¦ ì‹¤íŒ¨")
```

---

## âœ… 5. ì²´í¬ë¦¬ìŠ¤íŠ¸

### P0 ì™„ë£Œ ì¡°ê±´ (2ì¼)
- [ ] SQL ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
- [ ] ì •í•©ì„± ê²€ì¦ í†µê³¼ (10/10)
- [ ] ì„ë² ë”© ìƒì„± ì™„ë£Œ (10/10)
- [ ] FAISS ê²€ìƒ‰ í…ŒìŠ¤íŠ¸ ì„±ê³µ

### P1 ì™„ë£Œ ì¡°ê±´ (1ì£¼)
- [ ] feature_text í’ˆì§ˆ 95% ì´ìƒ
- [ ] feature_json ì œê±° ì™„ë£Œ
- [ ] confusions ì •ê·œí™” ì™„ë£Œ
- [ ] ì¸ë±ìŠ¤ ìƒì„± ë° ì„±ëŠ¥ ì¸¡ì •

### P2 ì™„ë£Œ ì¡°ê±´ (ì„ íƒ)
- [ ] Zero ê°’ NULL ì²˜ë¦¬
- [ ] ë ˆì½”ë“œ í¬ê¸° 8KB ì´í•˜ í™•ì¸
- [ ] ìŠ¤í† ë¦¬ì§€ 20% ì ˆê° í™•ì¸

---

## ğŸ“ 6. ë‹¤ìŒ ë‹¨ê³„

### ì¦‰ì‹œ ì‹¤í–‰
```bash
# 1. SQL ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
psql -h [HOST] -U [USER] -d [DB] -f metadata_fix.sql

# 2. ì„ë² ë”© ìƒì„±
python generate_embeddings.py

# 3. ê²€ì¦
psql -h [HOST] -U [USER] -d [DB] -c "
SELECT 
    COUNT(*) AS total,
    COUNT(CASE WHEN expected_stud_count > 0 THEN 1 END) AS fixed,
    COUNT(CASE WHEN clip_text_emb != '[0,0,0...' THEN 1 END) AS embedded
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133;
"
```

### ì „ì²´ ë¶€í’ˆ í™•ì¥ (20,000ê°œ)
```sql
-- ë°°ì¹˜ ì²˜ë¦¬ (1000ê°œì”©)
DO $$
DECLARE
    batch_start INTEGER;
BEGIN
    FOR batch_start IN 1..20000 BY 1000 LOOP
        -- P0 ìˆ˜ì • ì ìš©
        UPDATE parts_master_features
        SET expected_stud_count = (feature_json->>'stud_count_top')::INTEGER
        WHERE id BETWEEN batch_start AND (batch_start + 999)
          AND expected_stud_count = 0;
        
        COMMIT;
        PERFORM pg_sleep(0.1);  -- ë¶€í•˜ ë¶„ì‚°
    END LOOP;
END $$;
```

---

**ìµœì¢… ëª©í‘œ**: 
- âœ… ì‹œìŠ¤í…œ ì‘ë™ ë³µêµ¬ (ì„ë² ë”©, ê²€ìƒ‰)
- âœ… ë°ì´í„° ì •í•©ì„± 100%
- âœ… ê²€ìƒ‰ ì •í™•ë„ 90% ì´ìƒ
- âœ… ì„¸íŠ¸ ë¡œë“œ ì‹œê°„ 73% ê°œì„ 

**ì˜ˆìƒ ì´ ì†Œìš” ì‹œê°„**: P0 2ì¼ + P1 1ì£¼ = **9ì¼**

