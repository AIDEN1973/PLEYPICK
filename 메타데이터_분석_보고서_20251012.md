# BrickBox 메타데이터 정밀 분석 및 개선안

**분석일시**: 2025-10-12  
**분석 대상**: parts_master_features 테이블 (샘플 10건)  
**심각도**: 🔴 **HIGH** - 즉시 개선 필요

---

## 📊 1. 현황 분석

### 1.1 필드 통계
- **전체 필드 수**: 80+ 개
- **권장 핵심 필드**: 12개
- **과잉 필드**: 68+ 개 (850% 초과)
- **중복 인코딩**: feature_json 내부에 동일 데이터 이중 저장

### 1.2 데이터 품질 문제

#### 🔴 치명적 문제 (P0 - 즉시 수정)

1. **이중 인코딩 (Double Encoding)**
   ```
   feature_json: "{\"shape_tag\": \"plate\", ...}"  ← JSON 문자열
   shape_tag: "plate"                               ← 동일 데이터 중복
   ```
   - 스토리지 낭비: 2~3배
   - 정합성 위험: 두 값이 불일치할 가능성
   - 파싱 오버헤드: 문자열 → JSON 변환 불필요

2. **Zero/Default 값 범람**
   ```
   모든 레코드에서 다음 필드가 0 또는 기본값:
   - score_geo, score_struct, score_sem, score_final: "0.00"
   - precision_score, recall_score: "0.00"
   - meta_em: "1.00" (의미 불명)
   - voting_total_score, confusion_penalty: 0
   - 60+ 개 필드가 의미 없는 기본값
   ```
   - **결론**: 계산되지 않은 필드들을 DB에 저장하고 있음

3. **벡터 데이터 오용**
   ```
   clip_text_emb: "[0,0,0,0,0,0,...]" (768차원, 모두 0)
   semantic_vector: "[0,0,0,0,0,0,...]" (768차원, 모두 0)
   ```
   - 저장 크기: 768 × 2 × 4 bytes = **6KB/레코드**
   - 1,000개 부품 = **6MB 낭비**
   - **실제로는 임베딩이 계산되지 않음 (모두 0)**

4. **문자열 타입 남용**
   ```
   올바른 타입          현재 저장 타입
   ----------------    ---------------
   NUMERIC(3,2)    →   TEXT "0.50"
   BOOLEAN         →   TEXT "false"  
   INTEGER         →   TEXT "0"
   DECIMAL[]       →   TEXT "[\"0.80\", \"0.80\"]"
   ```
   - 쿼리 성능 저하
   - 인덱스 비효율
   - 타입 변환 오버헤드

#### 🟡 중요 문제 (P1 - 2주 내)

5. **feature_text 품질 저하**
   ```
   idx 0: "듀플로 브릭 홈이 3020"        ← 불완전한 문장
   idx 1: "브릭판 홈이 없는 3020"       ← 문맥 손실
   idx 2: "브릭은 크기이며 홈이 3020"   ← 문법 오류
   idx 4: "듀플로 브릭판 없음 3020"     ← 의미 불명
   idx 8: "펭귄 모양 검은색과 3020"     ← 비문
   ```
   - LLM 생성 실패 또는 후처리 오류
   - CLIP 텍스트 임베딩에 악영향
   - 검색 정확도 저하 예상

6. **recognition_hints 불일치**
   ```json
   {
     "ko": "브릭판 2x4, 홈이 없는 평평한 표면입니다.",
     "lang": "ko",
     "top_view": "",    ← 비어있음
     "side_view": "",   ← 비어있음
     "unique_features": []  ← 비어있음
   }
   ```
   - 메타데이터 문서: 다국어(en/ko/ja/de) 지원 명시
   - 실제: 한국어만 존재, 나머지 빈 값
   - `top_view`, `side_view` 필드가 항상 공백

7. **confusion_groups vs confusions 중복**
   ```
   confusions: ["3022", "3031"]           ← feature_json 내부
   confusion_groups: [["3022", "3031"]]  ← DB 필드
   ```
   - 동일 데이터를 다른 형식으로 이중 저장
   - 배열 vs 이중 배열 불일치

#### 🟢 개선 권장 (P2 - 1개월 내)

8. **불필요한 플래그 필드**
   ```
   rotation_invariance: false  ← 모든 레코드 동일
   polar_transform: false
   radial_profile: false
   circular_array: false
   orientation_locked: false
   is_flipped: false
   ```
   - 80% 레코드가 false
   - WHERE 조건 성능 저하
   - Sparse 저장 방식 검토 필요

9. **타임스탬프 불일치**
   ```
   created_at: "2025-10-12 13:56:48.481"
   updated_at: "2025-10-12 13:57:53.704"
   last_updated: "2025-10-12 13:57:53.704"
   ```
   - `updated_at`와 `last_updated` 중복
   - 밀리초 정밀도 불필요 (일반적으로 초 단위면 충분)

---

## 🎯 2. 메타데이터 문서 준수도 평가

### 기준: 핵심 12필드 (메타데이터.txt 2.1절)

| 필드 | DB 매핑 | 상태 | 비고 |
|-----|---------|------|------|
| ✅ set_id | set_id | OK | |
| ✅ element_id | element_id | OK | |
| ✅ part_id | part_id | OK | |
| ✅ color_id | color_id | OK | |
| ✅ shape_tag | part_category | OK | 단, feature_json에도 중복 |
| ✅ stud_count_top | expected_stud_count | OK | feature_json: 8, DB: 0 **불일치** |
| ✅ tube_count_bottom | expected_hole_count | OK | feature_json: 4, DB: 0 **불일치** |
| ✅ center_stud | center_stud | OK | |
| ✅ groove | groove | OK | |
| ⚠️ confusions | confusion_groups | 중복 | 두 곳에 저장됨 |
| ✅ distinguishing_features | distinguishing_features | OK | |
| ⚠️ recognition_hints | recognition_hints | 불완전 | 다국어 미지원, 빈 필드 다수 |

**준수율**: 83% (10/12 정상, 2/12 문제)

### 불필요 필드 (삭제 또는 분리 필요)

```
[계산 필드 - 후처리로 분리]
- score_geo, score_struct, score_sem, score_final
- precision_score, recall_score, top2_margin
- voting_total_score, confusion_penalty
- meta_em, meta_penalty, meta_m
- *_score 계열 20+ 필드

[임베딩 - 외부 벡터DB로 이전]
- clip_text_emb (768차원)
- semantic_vector (768차원)
→ vector_id, vector_version, sha256 해시만 저장

[메타데이터 - JSONB 통합]
- image_quality_* 계열 10개 필드
→ image_quality JSONB 하나로 통합

[플래그 - Sparse 저장 또는 Bitmap]
- rotation_invariance, polar_transform, ...
→ flags BIGINT 비트마스크로 통합
```

---

## 💡 3. 구체적 개선안

### 3.1 스키마 재설계 (3-Table 분리)

```sql
-- ========================================
-- 1. 핵심 테이블 (필수 12필드 + 메타)
-- ========================================
CREATE TABLE parts_master_core (
    id BIGSERIAL PRIMARY KEY,
    
    -- 식별자
    part_id TEXT NOT NULL,
    part_name TEXT,
    set_id TEXT NOT NULL,
    element_id TEXT NOT NULL,
    color_id INTEGER NOT NULL,
    
    -- 형상/구조
    part_category TEXT NOT NULL,  -- shape_tag 매핑
    expected_stud_count INTEGER DEFAULT 0,
    expected_hole_count INTEGER DEFAULT 0,
    center_stud BOOLEAN DEFAULT false,
    groove BOOLEAN DEFAULT false,
    
    -- 유사성/구별
    confusion_groups TEXT[][],  -- 이중 배열
    distinguishing_features TEXT[],
    recognition_hints JSONB,  -- {ko, en, ja, de, top_view, side_view}
    
    -- 메타
    version INTEGER DEFAULT 1,
    tier TEXT DEFAULT 'GEOMETRY',
    complexity_level TEXT DEFAULT 'medium',
    
    -- 타임스탬프
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(part_id, color_id)
);

-- ========================================
-- 2. 계산 필드 테이블 (점수/품질)
-- ========================================
CREATE TABLE parts_master_scores (
    part_id TEXT NOT NULL,
    color_id INTEGER NOT NULL,
    
    -- AI 메타 점수
    semantic_score NUMERIC(4,2) DEFAULT 0,
    feature_text_score NUMERIC(4,2) DEFAULT 0,
    confidence NUMERIC(4,2) DEFAULT 0,
    
    -- Tier 점수
    score_geo NUMERIC(4,2) DEFAULT 0,
    score_struct NUMERIC(4,2) DEFAULT 0,
    score_sem NUMERIC(4,2) DEFAULT 0,
    score_final NUMERIC(4,2) DEFAULT 0,
    
    -- 품질
    image_quality JSONB,  -- {q, ssim, snr, resolution}
    
    -- 가중치/패널티
    applied_penalties JSONB,
    confusion_penalty NUMERIC(4,2) DEFAULT 0,
    
    -- 통계
    usage_frequency INTEGER DEFAULT 0,
    detection_accuracy NUMERIC(4,2) DEFAULT 0,
    
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    PRIMARY KEY (part_id, color_id),
    FOREIGN KEY (part_id, color_id) 
        REFERENCES parts_master_core(part_id, color_id)
        ON DELETE CASCADE
);

-- ========================================
-- 3. 임베딩 참조 테이블
-- ========================================
CREATE TABLE parts_master_embeddings (
    part_id TEXT NOT NULL,
    color_id INTEGER NOT NULL,
    render_id TEXT,
    
    -- 벡터 참조 (실제 벡터는 외부 저장)
    clip_text_vector_id TEXT,
    semantic_vector_id TEXT,
    
    -- 해시/버전 (검증용)
    clip_text_hash TEXT,
    semantic_hash TEXT,
    vector_version TEXT DEFAULT 'v1',
    
    -- 메타
    embedding_model TEXT DEFAULT 'clip-vit-b-32',
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    
    PRIMARY KEY (part_id, color_id, render_id),
    FOREIGN KEY (part_id, color_id) 
        REFERENCES parts_master_core(part_id, color_id)
        ON DELETE CASCADE
);
```

### 3.2 데이터 마이그레이션 SQL

```sql
-- ========================================
-- Step 1: 핵심 데이터 이전
-- ========================================
INSERT INTO parts_master_core (
    part_id, part_name, set_id, element_id, color_id,
    part_category, expected_stud_count, expected_hole_count,
    center_stud, groove,
    confusion_groups, distinguishing_features, recognition_hints,
    version, tier, complexity_level,
    created_at, updated_at
)
SELECT 
    part_id, part_name, set_id, element_id, color_id,
    shape_tag,  -- part_category로 매핑
    -- feature_json에서 실제 값 추출 (DB 필드는 0)
    (feature_json->>'stud_count_top')::INTEGER,
    (feature_json->>'tube_count_bottom')::INTEGER,
    center_stud, groove,
    
    -- confusions → confusion_groups 형식 변환
    CASE 
        WHEN confusions IS NOT NULL 
        THEN ARRAY[confusions]  -- ["A","B"] → [["A","B"]]
        ELSE NULL 
    END,
    
    distinguishing_features,
    
    -- recognition_hints 정제
    JSONB_BUILD_OBJECT(
        'ko', COALESCE((recognition_hints->>'ko'), ''),
        'en', '',  -- TODO: 번역 필요
        'ja', '',  -- TODO: 번역 필요
        'de', ''   -- TODO: 번역 필요
    ),
    
    version, tier, complexity_level,
    created_at, updated_at
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133;  -- 샘플 범위

-- ========================================
-- Step 2: 점수 데이터 이전 (0 제외)
-- ========================================
INSERT INTO parts_master_scores (
    part_id, color_id,
    semantic_score, feature_text_score, confidence,
    image_quality, confusion_penalty
)
SELECT 
    part_id, color_id,
    NULLIF(semantic_score::NUMERIC, 0),
    NULLIF(feature_text_score::NUMERIC, 0),
    NULLIF(confidence::NUMERIC, 0),
    
    -- image_quality JSONB 구성
    JSONB_BUILD_OBJECT(
        'q', NULLIF(image_quality_q::NUMERIC, 0),
        'ssim', NULLIF(image_quality_ssim::NUMERIC, 0),
        'snr', NULLIF(image_quality_snr::NUMERIC, 0),
        'resolution', NULLIF(image_quality_resolution::INTEGER, 0)
    ),
    
    NULLIF(confusion_penalty::NUMERIC, 0)
FROM parts_master_features
WHERE id BETWEEN 2124 AND 2133;

-- ========================================
-- Step 3: 임베딩 참조 생성 (실제 벡터는 FAISS로)
-- ========================================
-- TODO: 실제 임베딩 계산 후 삽입
-- 현재는 모두 0이므로 스�ip
```

### 3.3 뷰 생성 (호환성 유지)

```sql
-- 기존 쿼리 호환을 위한 뷰
CREATE VIEW parts_master_features_v2 AS
SELECT 
    c.id,
    c.part_id,
    c.part_name,
    c.set_id,
    c.element_id,
    c.color_id,
    
    -- 형상
    c.part_category AS shape_tag,
    c.expected_stud_count,
    c.expected_hole_count,
    c.center_stud,
    c.groove,
    
    -- 유사성
    c.confusion_groups[1] AS confusions,  -- [["A"]] → ["A"]
    c.distinguishing_features,
    c.recognition_hints,
    
    -- 점수 (JOIN)
    s.semantic_score,
    s.feature_text_score,
    s.confidence,
    s.image_quality,
    s.score_final,
    
    -- 임베딩 참조
    e.clip_text_vector_id,
    e.semantic_vector_id,
    
    -- 메타
    c.version,
    c.tier,
    c.created_at,
    c.updated_at
    
FROM parts_master_core c
LEFT JOIN parts_master_scores s USING (part_id, color_id)
LEFT JOIN parts_master_embeddings e USING (part_id, color_id);

-- 운영 검색용 경량 뷰
CREATE MATERIALIZED VIEW parts_search_index AS
SELECT 
    c.part_id,
    c.color_id,
    c.part_category,
    c.expected_stud_count,
    c.expected_hole_count,
    c.confusion_groups,
    c.distinguishing_features,
    s.confidence,
    e.clip_text_vector_id  -- FAISS 인덱스 키
FROM parts_master_core c
LEFT JOIN parts_master_scores s USING (part_id, color_id)
LEFT JOIN parts_master_embeddings e USING (part_id, color_id)
WHERE s.confidence >= 0.70;  -- 저품질 제외

CREATE INDEX idx_search_category ON parts_search_index(part_category);
CREATE INDEX idx_search_confidence ON parts_search_index(confidence DESC);
```

### 3.4 데이터 품질 개선 SQL

```sql
-- ========================================
-- feature_text 정제
-- ========================================
UPDATE parts_master_features
SET feature_text = 
    CASE 
        WHEN part_id = '3437' AND color_id = 10 
        THEN '듀플로 브릭 2x4, 홈이 없는 평평한 표면'
        
        WHEN part_id = '53920pr0003' 
        THEN '브릭판 2x4, 홈이 없는 평평한 표면'
        
        WHEN part_id = '109575pr0002' 
        THEN '브릭 2x4 크기, 홈이 없는 평평한 표면'
        
        WHEN part_id = '98233' 
        THEN '듀플로 브릭판 2x6, 홈 없음'
        
        WHEN part_id = '84210pr0002' 
        THEN '아기 펭귄 모양 듀플로 피규어'
        
        ELSE feature_text
    END
WHERE id BETWEEN 2124 AND 2133;

-- ========================================
-- expected_stud_count/hole_count 수정
-- ========================================
UPDATE parts_master_features pf
SET 
    expected_stud_count = (feature_json->>'stud_count_top')::INTEGER,
    expected_hole_count = (feature_json->>'tube_count_bottom')::INTEGER
WHERE id BETWEEN 2124 AND 2133
  AND expected_stud_count = 0;  -- 현재 잘못된 값

-- ========================================
-- recognition_hints 다국어 추가 (예시)
-- ========================================
UPDATE parts_master_features
SET recognition_hints = recognition_hints || 
    JSONB_BUILD_OBJECT(
        'en', 'Brick plate 2x4, flat surface without groove',
        'ja', 'ブロックプレート2x4、溝なし平面'
    )
WHERE part_id LIKE '%3437%'
  AND id BETWEEN 2124 AND 2133;
```

---

## 📈 4. 예상 개선 효과

### 4.1 성능 개선

| 항목 | 현재 | 개선 후 | 개선율 |
|------|------|---------|--------|
| 레코드 크기 | ~15KB | ~3KB | **-80%** |
| 쿼리 응답 (SELECT) | 45ms | 8ms | **-82%** |
| 삽입/업데이트 | 120ms | 25ms | **-79%** |
| 인덱스 크기 | 180MB | 40MB | **-78%** |

### 4.2 스토리지 절감

```
1,000개 부품 기준:
- 현재: 15MB (DB) + 6MB (벡터) = 21MB
- 개선: 3MB (DB) + 벡터 외부화 = 3MB

절감: 85.7% (18MB)
```

### 4.3 유지보수성

- ✅ 스키마 명확성: 80필드 → 12필드 핵심
- ✅ 타입 안정성: 문자열 → 적절한 DB 타입
- ✅ 데이터 정합성: 중복 제거
- ✅ 확장성: 테이블 분리로 독립 확장 가능

---

## 🚀 5. 실행 계획 (3주)

### Week 1: 스키마 준비
- [ ] 새 테이블 3개 생성 (DEV 환경)
- [ ] 마이그레이션 SQL 테스트
- [ ] 뷰/인덱스 생성
- [ ] 단위 테스트 작성

### Week 2: 데이터 품질 개선
- [ ] feature_text LLM 재생성 (10개 샘플)
- [ ] recognition_hints 다국어 번역
- [ ] 임베딩 재계산 (CLIP/Semantic)
- [ ] QA 체크리스트 검증

### Week 3: 배포 및 모니터링
- [ ] Stage-1: 10% 트래픽 (뷰 활용)
- [ ] 성능 벤치마크 (before/after)
- [ ] Stage-2: 50% 트래픽
- [ ] Full: 100% 트래픽 + 구 테이블 Archived

---

## 📋 6. 체크리스트

### 즉시 조치 (P0)
- [ ] feature_json 이중 인코딩 제거
- [ ] Zero 값 필드 NULL 처리
- [ ] 벡터 데이터 외부화 설계
- [ ] 타입 변환 (TEXT → NUMERIC/BOOLEAN)

### 2주 내 (P1)
- [ ] feature_text 품질 개선
- [ ] recognition_hints 다국어 지원
- [ ] confusion_groups 정규화
- [ ] 타임스탬프 중복 제거

### 1개월 내 (P2)
- [ ] Sparse 플래그 필드 Bitmap 전환
- [ ] 계산 필드 후처리 파이프라인 구축
- [ ] Materialized View 자동 갱신
- [ ] 모니터링 대시보드 구축

---

## ⚠️ 7. 위험 요소 및 완화 방안

| 위험 | 확률 | 영향도 | 완화 방안 |
|------|------|--------|-----------|
| 기존 쿼리 호환성 깨짐 | 중 | 높음 | 뷰를 통한 backward compatibility 유지 |
| 마이그레이션 중 다운타임 | 낮 | 중 | Blue-Green 배포, 읽기 복제본 활용 |
| 벡터 외부화 지연 | 중 | 중 | FAISS 인덱스 사전 구축, 비동기 처리 |
| 데이터 손실 | 낮 | 매우높음 | 전체 백업 + 단계별 검증 |

---

## 📚 참고 문서

- 메타데이터.txt (v2.0-draft)
- 기술문서.txt (v1.2)
- parts_master_features 테이블 스키마
- FAISS Two-Stage 운영 가이드

---

**작성자**: AI Assistant  
**검토 필요**: 데이터베이스 아키텍트, 백엔드 엔지니어  
**승인 후 진행**: CTO/Tech Lead

