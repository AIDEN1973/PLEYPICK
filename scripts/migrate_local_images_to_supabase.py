#!/usr/bin/env python3 """ 로컬 렌더링 이미지를 Supabase 버킷으로 마이그레이션하는 스크립트 기존에 로컬에만 저장된 렌더링 이미지를 Supabase Storage에 업로드하고 part_images 테이블에 동기화합니다. 사용법: python migrate_local_images_to_supabase.py --output-dir ./output/synthetic """ import os import sys import glob import json import argparse from pathlib import Path from dotenv import load_dotenv # Supabase 클라이언트 try: from supabase import create_client SUPABASE_AVAILABLE = True except ImportError: print(" Supabase 패키지가 설치되지 않았습니다.") print("설치: pip install supabase") SUPABASE_AVAILABLE = False sys.exit(1) def load_env_variables(): """환경 변수 로드""" # 다양한 경로의 .env 파일 시도 env_paths = [ '.env.blender', 'config/synthetic_dataset.env', '.env' ] for env_path in env_paths: if os.path.exists(env_path): load_dotenv(env_path) print(f" 환경 변수 로드: {env_path}") break supabase_url = os.getenv('VITE_SUPABASE_URL') or os.getenv('SUPABASE_URL') supabase_key = os.getenv('VITE_SUPABASE_ANON_KEY') or os.getenv('SUPABASE_KEY') if not supabase_url or not supabase_key: print(" Supabase 환경 변수가 설정되지 않았습니다.") print("필요한 환경 변수: VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY") sys.exit(1) return supabase_url, supabase_key def upload_image_to_supabase(supabase, image_path, part_id, color_id): """이미지를 Supabase 버킷에 업로드하고 DB에 동기화""" try: filename = f"{part_id}_{color_id}.webp" storage_path = f"images/{filename}" print(f" 업로드 중: {storage_path}") # 이미지 파일 읽기 with open(image_path, 'rb') as f: image_data = f.read() # lego_parts_images 버킷에 업로드 result = supabase.storage.from_('lego_parts_images').upload( storage_path, image_data, file_options={ "content-type": "image/webp", "upsert": "true", "cache-control": "public, max-age=31536000" } ) # 업로드 결과 확인 if hasattr(result, 'error') and result.error: print(f" 업로드 실패: {result.error}") return None # 공개 URL 생성 public_url = supabase.storage.from_('lego_parts_images').get_public_url(storage_path) # part_images 테이블에 동기화 try: payload = { 'part_id': str(part_id), 'color_id': int(color_id), 'original_url': public_url, 'uploaded_url': public_url, 'filename': filename, 'upload_status': 'completed' } # upsert 시도 update_result = supabase.table('part_images').update(payload).eq('part_id', str(part_id)).eq('color_id', int(color_id)).execute() if hasattr(update_result, 'data') and (not update_result.data or len(update_result.data) == 0): insert_result = supabase.table('part_images').insert(payload).execute() if hasattr(insert_result, 'error') and insert_result.error: print(f" DB 삽입 실패: {insert_result.error}") else: print(f" DB 삽입 완료: {part_id}_{color_id}") else: print(f" DB 업데이트 완료: {part_id}_{color_id}") except Exception as db_error: print(f" DB 동기화 실패: {db_error}") return public_url except Exception as e: print(f" 업로드 실패: {e}") import traceback traceback.print_exc() return None def extract_part_info_from_path(image_path): """파일 경로에서 part_id와 color_id 추출""" try: # 파일명 형식: {part_id}_{index}.webp 또는 {element_id}_{index}.webp filename = os.path.basename(image_path) name_without_ext = filename.replace('.webp', '').replace('.png', '') # _{index} 제거 if '_' in name_without_ext: parts = name_without_ext.rsplit('_', 1) if parts[-1].isdigit(): part_id = parts[0] else: part_id = name_without_ext else: part_id = name_without_ext # 메타데이터 JSON 파일 확인 (color_id 추출) json_path = image_path.replace('.webp', '.json').replace('.png', '.json') color_id = 0 # 기본값 if os.path.exists(json_path): try: with open(json_path, 'r', encoding='utf-8') as f: metadata = json.load(f) color_id = metadata.get('material', {}).get('color_id', 0) except Exception: pass return part_id, color_id except Exception as e: print(f" 파일명 파싱 실패: {e}") return None, None def main(): parser = argparse.ArgumentParser(description='로컬 렌더링 이미지를 Supabase로 마이그레이션') parser.add_argument('--output-dir', default='./output/synthetic', help='렌더링 이미지 디렉토리') parser.add_argument('--dry-run', action='store_true', help='실제 업로드 없이 시뮬레이션만') args = parser.parse_args() # 환경 변수 로드 supabase_url, supabase_key = load_env_variables() # Supabase 클라이언트 연결 try: supabase = create_client(supabase_url, supabase_key) print(" Supabase 연결 성공") except Exception as e: print(f" Supabase 연결 실패: {e}") sys.exit(1) # 렌더링 이미지 검색 output_dir = Path(args.output_dir) if not output_dir.exists(): print(f" 디렉토리가 존재하지 않습니다: {output_dir}") sys.exit(1) # WebP 이미지 파일 찾기 image_files = list(output_dir.glob('**/*.webp')) print(f" 발견된 이미지: {len(image_files)}개") if args.dry_run: print(" DRY RUN 모드: 실제 업로드는 수행하지 않습니다.") # 마이그레이션 실행 success_count = 0 fail_count = 0 for image_path in image_files: part_id, color_id = extract_part_info_from_path(str(image_path)) if not part_id: print(f"⏭️ 건너뛰기: {image_path.name} (파일명 파싱 실패)") continue print(f"\n 처리 중: {image_path.name} (part_id={part_id}, color_id={color_id})") if args.dry_run: print(f" → 업로드 예정: images/{part_id}_{color_id}.webp") success_count += 1 else: result = upload_image_to_supabase(supabase, str(image_path), part_id, color_id) if result: success_count += 1 print(f" 완료: {result}") else: fail_count += 1 # 결과 요약 print("\n" + "="*60) print(" 마이그레이션 완료") print(f" 성공: {success_count}개") print(f" 실패: {fail_count}개") print("="*60) if __name__ == '__main__': main() 