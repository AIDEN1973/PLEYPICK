#!/usr/bin/env python3 """ BrickBox Queue Manager Message Queue 기반 워커 호출 (Redis/TaskQ) """ import os import json import time import threading from datetime import datetime from typing import Dict, List, Optional, Callable, Any import logging from dataclasses import dataclass from enum import Enum logger = logging.getLogger(__name__) class TaskStatus(Enum): PENDING = "pending" PROCESSING = "processing" COMPLETED = "completed" FAILED = "failed" RETRY = "retry" @dataclass class Task: """작업 정의""" id: str type: str payload: Dict status: TaskStatus created_at: str updated_at: str retry_count: int = 0 max_retries: int = 3 priority: int = 0 worker: str = None error: str = None class QueueManager: """Queue 관리자 (파일 기반 → Redis 이관 준비)""" def __init__(self, queue_dir: str = "queues", backend: str = "file"): self.backend = backend self.queue_dir = queue_dir if backend == "redis": self._init_redis_backend() else: self._init_file_backend() def _init_file_backend(self): """파일 기반 백엔드 초기화""" self.queues = { "rendering": os.path.join(self.queue_dir, "rendering_queue.jsonl"), "embedding": os.path.join(self.queue_dir, "embedding_queue.jsonl"), "fusion": os.path.join(self.queue_dir, "fusion_queue.jsonl"), "qa": os.path.join(self.queue_dir, "qa_queue.jsonl") } self._ensure_queue_files() def _init_redis_backend(self): """Redis 백엔드 초기화""" try: import redis self.redis_client = redis.Redis( host=os.getenv('REDIS_HOST', 'localhost'), port=int(os.getenv('REDIS_PORT', 6379)), db=int(os.getenv('REDIS_DB', 0)), decode_responses=True ) # 연결 테스트 self.redis_client.ping() logger.info(" Redis 백엔드 연결 성공") except Exception as e: logger.error(f" Redis 연결 실패: {e}") logger.info(" 파일 백엔드로 폴백") self.backend = "file" self._init_file_backend() self.workers = {} self.running = False # 큐 디렉토리 생성 os.makedirs(self.queue_dir, exist_ok=True) def _ensure_queue_files(self): """큐 파일 생성""" os.makedirs(self.queue_dir, exist_ok=True) for queue_path in self.queues.values(): if not os.path.exists(queue_path): with open(queue_path, 'w', encoding='utf-8') as f: pass def create_task(self, task_type: str, payload: Dict, priority: int = 0, max_retries: int = 3) -> str: """작업 생성""" try: task_id = f"{task_type}_{int(time.time() * 1000)}" task = Task( id=task_id, type=task_type, payload=payload, status=TaskStatus.PENDING, created_at=datetime.now().isoformat(), updated_at=datetime.now().isoformat(), max_retries=max_retries, priority=priority ) if self.backend == "redis": return self._create_task_redis(task) else: return self._create_task_file(task) except Exception as e: logger.error(f" 작업 생성 실패: {e}") return None def _task_to_dict(self, task: Task) -> Dict: """Task 객체를 딕셔너리로 변환 (JSON 직렬화 가능)""" task_dict = task.__dict__.copy() if isinstance(task_dict.get('status'), TaskStatus): task_dict['status'] = task_dict['status'].value return task_dict def _create_task_redis(self, task: Task) -> str: """Redis 백엔드 작업 생성""" try: # Redis List에 작업 추가 (우선순위 포함) queue_key = f"queue:{task.type}" task_dict = self._task_to_dict(task) task_data = json.dumps(task_dict, ensure_ascii=False) # 우선순위를 점수로 사용하여 정렬된 세트에 추가 self.redis_client.zadd(f"{queue_key}:pending", {task_data: task.priority}) logger.info(f" Redis 작업 생성: {task.id} ({task.type})") return task.id except Exception as e: logger.error(f" Redis 작업 생성 실패: {e}") return None def _create_task_file(self, task: Task) -> str: """파일 백엔드 작업 생성""" try: queue_path = self.queues.get(task.type) if not queue_path: logger.error(f" 알 수 없는 작업 타입: {task.type}") return None task_dict = self._task_to_dict(task) with open(queue_path, 'a', encoding='utf-8') as f: f.write(json.dumps(task_dict, ensure_ascii=False) + '\n') logger.info(f" 파일 작업 생성: {task.id} ({task.type})") return task.id except Exception as e: logger.error(f" 파일 작업 생성 실패: {e}") return None def get_next_task(self, task_type: str) -> Optional[Task]: """다음 작업 조회 (우선순위 기반)""" try: queue_path = self.queues.get(task_type) if not queue_path or not os.path.exists(queue_path): return None tasks = [] with open(queue_path, 'r', encoding='utf-8') as f: for line in f: try: task_data = json.loads(line.strip()) task = Task(**task_data) if task.status == TaskStatus.PENDING: tasks.append(task) except (json.JSONDecodeError, TypeError): continue if not tasks: return None # 우선순위 정렬 (높은 우선순위 먼저) tasks.sort(key=lambda x: x.priority, reverse=True) return tasks[0] except Exception as e: logger.error(f" 다음 작업 조회 실패: {e}") return None def update_task_status(self, task_id: str, status: TaskStatus, worker: str = None, error: str = None) -> bool: """작업 상태 업데이트""" try: # 모든 큐에서 작업 찾기 for task_type, queue_path in self.queues.items(): if not os.path.exists(queue_path): continue updated_tasks = [] task_found = False with open(queue_path, 'r', encoding='utf-8') as f: for line in f: try: task_data = json.loads(line.strip()) task = Task(**task_data) if task.id == task_id: task.status = status task.updated_at = datetime.now().isoformat() if worker: task.worker = worker if error: task.error = error if status == TaskStatus.FAILED: task.retry_count += 1 task_found = True updated_tasks.append(task) except (json.JSONDecodeError, TypeError): continue if task_found: # 업데이트된 작업들 저장 with open(queue_path, 'w', encoding='utf-8') as f: for task in updated_tasks: task_dict = self._task_to_dict(task) f.write(json.dumps(task_dict, ensure_ascii=False) + '\n') logger.info(f" 작업 상태 업데이트: {task_id} -> {status.value}") return True logger.warning(f" 작업을 찾을 수 없음: {task_id}") return False except Exception as e: logger.error(f" 작업 상태 업데이트 실패: {e}") return False def register_worker(self, worker_name: str, task_type: str, handler: Callable[[Task], bool]) -> bool: """워커 등록""" try: self.workers[worker_name] = { "task_type": task_type, "handler": handler, "status": "idle" } logger.info(f" 워커 등록: {worker_name} ({task_type})") return True except Exception as e: logger.error(f" 워커 등록 실패: {e}") return False def start_worker(self, worker_name: str, poll_interval: float = 1.0) -> bool: """워커 시작""" try: if worker_name not in self.workers: logger.error(f" 등록되지 않은 워커: {worker_name}") return False worker_info = self.workers[worker_name] task_type = worker_info["task_type"] handler = worker_info["handler"] def worker_loop(): logger.info(f" 워커 시작: {worker_name}") self.running = True while self.running: try: # 다음 작업 조회 task = self.get_next_task(task_type) if not task: time.sleep(poll_interval) continue # 작업 상태를 처리 중으로 변경 self.update_task_status(task.id, TaskStatus.PROCESSING, worker_name) worker_info["status"] = "processing" # 작업 처리 success = handler(task) if success: self.update_task_status(task.id, TaskStatus.COMPLETED, worker_name) logger.info(f" 작업 완료: {task.id}") else: # 재시도 로직 if task.retry_count < task.max_retries: self.update_task_status(task.id, TaskStatus.RETRY, worker_name) logger.warning(f" 작업 재시도: {task.id} ({task.retry_count + 1}/{task.max_retries})") else: self.update_task_status(task.id, TaskStatus.FAILED, worker_name, "Max retries exceeded") logger.error(f" 작업 실패: {task.id}") worker_info["status"] = "idle" except Exception as e: logger.error(f" 워커 오류: {e}") worker_info["status"] = "error" time.sleep(poll_interval) # 워커 스레드 시작 worker_thread = threading.Thread(target=worker_loop, daemon=True) worker_thread.start() return True except Exception as e: logger.error(f" 워커 시작 실패: {e}") return False def stop_worker(self, worker_name: str) -> bool: """워커 중지""" try: if worker_name in self.workers: self.workers[worker_name]["status"] = "stopped" logger.info(f" 워커 중지: {worker_name}") return True else: logger.warning(f" 등록되지 않은 워커: {worker_name}") return False except Exception as e: logger.error(f" 워커 중지 실패: {e}") return False def get_queue_stats(self, task_type: str = None) -> Dict: """큐 통계 조회""" try: stats = { "total_tasks": 0, "pending_tasks": 0, "processing_tasks": 0, "completed_tasks": 0, "failed_tasks": 0, "retry_tasks": 0 } queues_to_check = [task_type] if task_type else self.queues.keys() for queue_type in queues_to_check: queue_path = self.queues.get(queue_type) if not queue_path or not os.path.exists(queue_path): continue with open(queue_path, 'r', encoding='utf-8') as f: for line in f: try: task_data = json.loads(line.strip()) task = Task(**task_data) stats["total_tasks"] += 1 if task.status == TaskStatus.PENDING: stats["pending_tasks"] += 1 elif task.status == TaskStatus.PROCESSING: stats["processing_tasks"] += 1 elif task.status == TaskStatus.COMPLETED: stats["completed_tasks"] += 1 elif task.status == TaskStatus.FAILED: stats["failed_tasks"] += 1 elif task.status == TaskStatus.RETRY: stats["retry_tasks"] += 1 except (json.JSONDecodeError, TypeError): continue return stats except Exception as e: logger.error(f" 큐 통계 조회 실패: {e}") return {} def cleanup_completed_tasks(self, task_type: str, older_than_hours: int = 24) -> int: """완료된 작업 정리""" try: queue_path = self.queues.get(task_type) if not queue_path or not os.path.exists(queue_path): return 0 cutoff_time = datetime.now().timestamp() - (older_than_hours * 3600) remaining_tasks = [] cleaned_count = 0 with open(queue_path, 'r', encoding='utf-8') as f: for line in f: try: task_data = json.loads(line.strip()) task = Task(**task_data) # 완료된 작업이고 오래된 경우 제거 if (task.status == TaskStatus.COMPLETED and datetime.fromisoformat(task.updated_at).timestamp() < cutoff_time): cleaned_count += 1 else: remaining_tasks.append(task) except (json.JSONDecodeError, TypeError): continue # 남은 작업들 저장 with open(queue_path, 'w', encoding='utf-8') as f: for task in remaining_tasks: f.write(json.dumps(task.__dict__, ensure_ascii=False) + '\n') logger.info(f" 작업 정리 완료: {cleaned_count}개 제거") return cleaned_count except Exception as e: logger.error(f" 작업 정리 실패: {e}") return 0 def main(): """테스트 함수""" try: # Queue Manager 초기화 queue_manager = QueueManager("test_queues") # 테스트 작업 생성 task_id = queue_manager.create_task("embedding", {"part_id": "test_001", "image_path": "test.webp"}) print(f"작업 생성: {task_id}") # 큐 통계 조회 stats = queue_manager.get_queue_stats() print(f"큐 통계: {stats}") return True except Exception as e: logger.error(f" 테스트 실패: {e}") return False if __name__ == "__main__": main() 