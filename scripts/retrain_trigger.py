#!/usr/bin/env python3 """ BrickBox Retrain Trigger í’ˆì§ˆ ì €í•˜ ì‹œ í•™ìŠµ ì¬ì‹œì‘ ì¡°ê±´ ì •ì˜ """ import os import json import time import logging import requests from datetime import datetime, timedelta from typing import Dict, List, Optional, Tuple from dataclasses import dataclass from enum import Enum logger = logging.getLogger(__name__) class RetrainTriggerType(Enum): QUALITY_DEGRADATION = "quality_degradation" ACCURACY_DROP = "accuracy_drop" NEW_DATA_AVAILABLE = "new_data_available" SCHEDULED_RETRAIN = "scheduled_retrain" MANUAL_TRIGGER = "manual_trigger" @dataclass class RetrainTrigger: """ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì •ì˜""" trigger_type: RetrainTriggerType threshold_value: float current_value: float severity: str # "low", "medium", "high", "critical" description: str triggered_at: str metadata: Dict class RetrainTriggerManager: """ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ê´€ë¦¬ì""" def __init__(self, config_path: str = "config/retrain_config.json", supabase_client=None): self.config_path = config_path self.supabase = supabase_client self.triggers = [] self.config = self._load_config() self.slack_webhook_url = os.getenv('SLACK_WEBHOOK_URL') def _load_config(self) -> Dict: """ì„¤ì • ë¡œë“œ""" try: if os.path.exists(self.config_path): with open(self.config_path, 'r', encoding='utf-8') as f: return json.load(f) else: # ê¸°ë³¸ ì„¤ì • ìƒì„± default_config = { "quality_thresholds": { "ssim_min": 0.95, "snr_min": 30.0, "sharpness_min": 0.7, "noise_max": 0.15, "contrast_min": 0.3 }, "accuracy_thresholds": { "detection_accuracy_min": 0.90, "identification_accuracy_min": 0.85, "fusion_accuracy_min": 0.80 }, "retrain_conditions": { "quality_degradation_threshold": 0.05, # 5% í’ˆì§ˆ ì €í•˜ "accuracy_drop_threshold": 0.03, # 3% ì •í™•ë„ í•˜ë½ "consecutive_failures": 10, # ì—°ì† ì‹¤íŒ¨ íšŸìˆ˜ "data_volume_threshold": 1000, # ìƒˆ ë°ì´í„° 1000ê°œ "scheduled_interval_days": 30 # 30ì¼ë§ˆë‹¤ ì •ê¸° ì¬í•™ìŠµ }, "severity_levels": { "low": {"retrain_priority": 1, "notification": False}, "medium": {"retrain_priority": 2, "notification": True}, "high": {"retrain_priority": 3, "notification": True}, "critical": {"retrain_priority": 4, "notification": True} } } # ì„¤ì • íŒŒì¼ ì €ì¥ os.makedirs(os.path.dirname(self.config_path), exist_ok=True) with open(self.config_path, 'w', encoding='utf-8') as f: json.dump(default_config, f, ensure_ascii=False, indent=2) return default_config except Exception as e: logger.error(f" ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}") return {} def check_quality_degradation(self, current_metrics: Dict, historical_metrics: List[Dict]) -> Optional[RetrainTrigger]: """í’ˆì§ˆ ì €í•˜ ê²€ì‚¬""" try: if not historical_metrics: return None # ê³¼ê±° í‰ê·  í’ˆì§ˆ ê³„ì‚° historical_avg = self._calculate_historical_average(historical_metrics) # í˜„ì¬ í’ˆì§ˆê³¼ ë¹„êµ degradation_scores = [] for metric in ["ssim", "snr", "sharpness", "contrast"]: if metric in current_metrics and metric in historical_avg: current_val = current_metrics[metric] historical_val = historical_avg[metric] if historical_val > 0: degradation = (historical_val - current_val) / historical_val degradation_scores.append(degradation) if not degradation_scores: return None # í‰ê·  ì €í•˜ìœ¨ ê³„ì‚° avg_degradation = sum(degradation_scores) / len(degradation_scores) threshold = self.config.get("retrain_conditions", {}).get("quality_degradation_threshold", 0.05) if avg_degradation > threshold: severity = self._determine_severity(avg_degradation) trigger = RetrainTrigger( trigger_type=RetrainTriggerType.QUALITY_DEGRADATION, threshold_value=threshold, current_value=avg_degradation, severity=severity, description=f"í’ˆì§ˆ ì €í•˜ ê°ì§€: {avg_degradation:.3f} (ì„ê³„ê°’: {threshold:.3f})", triggered_at=datetime.now().isoformat(), metadata={ "current_metrics": current_metrics, "historical_avg": historical_avg, "degradation_scores": degradation_scores } ) logger.warning(f" í’ˆì§ˆ ì €í•˜ íŠ¸ë¦¬ê±°: {trigger.description}") return trigger return None except Exception as e: logger.error(f" í’ˆì§ˆ ì €í•˜ ê²€ì‚¬ ì‹¤íŒ¨: {e}") return None def check_accuracy_drop(self, current_accuracy: Dict, historical_accuracy: List[Dict]) -> Optional[RetrainTrigger]: """ì •í™•ë„ í•˜ë½ ê²€ì‚¬""" try: if not historical_accuracy: return None # ê³¼ê±° í‰ê·  ì •í™•ë„ ê³„ì‚° historical_avg = self._calculate_historical_average(historical_accuracy) # í˜„ì¬ ì •í™•ë„ì™€ ë¹„êµ accuracy_drops = [] for accuracy_type in ["detection_accuracy", "identification_accuracy", "fusion_accuracy"]: if accuracy_type in current_accuracy and accuracy_type in historical_avg: current_val = current_accuracy[accuracy_type] historical_val = historical_avg[accuracy_type] if historical_val > 0: drop = (historical_val - current_val) / historical_val accuracy_drops.append(drop) if not accuracy_drops: return None # í‰ê·  í•˜ë½ë¥  ê³„ì‚° avg_drop = sum(accuracy_drops) / len(accuracy_drops) threshold = self.config.get("retrain_conditions", {}).get("accuracy_drop_threshold", 0.03) if avg_drop > threshold: severity = self._determine_severity(avg_drop) trigger = RetrainTrigger( trigger_type=RetrainTriggerType.ACCURACY_DROP, threshold_value=threshold, current_value=avg_drop, severity=severity, description=f"ì •í™•ë„ í•˜ë½ ê°ì§€: {avg_drop:.3f} (ì„ê³„ê°’: {threshold:.3f})", triggered_at=datetime.now().isoformat(), metadata={ "current_accuracy": current_accuracy, "historical_avg": historical_avg, "accuracy_drops": accuracy_drops } ) logger.warning(f" ì •í™•ë„ í•˜ë½ íŠ¸ë¦¬ê±°: {trigger.description}") return trigger return None except Exception as e: logger.error(f" ì •í™•ë„ í•˜ë½ ê²€ì‚¬ ì‹¤íŒ¨: {e}") return None def check_consecutive_failures(self, failure_log: List[Dict]) -> Optional[RetrainTrigger]: """ì—°ì† ì‹¤íŒ¨ ê²€ì‚¬""" try: if not failure_log: return None # ìµœê·¼ ì‹¤íŒ¨ íšŸìˆ˜ ê³„ì‚° recent_failures = 0 cutoff_time = datetime.now() - timedelta(hours=24) # ìµœê·¼ 24ì‹œê°„ for failure in reversed(failure_log): failure_time = datetime.fromisoformat(failure.get("timestamp", "")) if failure_time < cutoff_time: break if failure.get("status") == "failed": recent_failures += 1 else: break # ì—°ì†ì„±ì´ ê¹¨ì§ threshold = self.config.get("retrain_conditions", {}).get("consecutive_failures", 10) if recent_failures >= threshold: severity = self._determine_severity(recent_failures / threshold) trigger = RetrainTrigger( trigger_type=RetrainTriggerType.QUALITY_DEGRADATION, threshold_value=threshold, current_value=recent_failures, severity=severity, description=f"ì—°ì† ì‹¤íŒ¨ ê°ì§€: {recent_failures}íšŒ (ì„ê³„ê°’: {threshold}íšŒ)", triggered_at=datetime.now().isoformat(), metadata={ "recent_failures": recent_failures, "failure_log": failure_log[-recent_failures:] } ) logger.warning(f" ì—°ì† ì‹¤íŒ¨ íŠ¸ë¦¬ê±°: {trigger.description}") return trigger return None except Exception as e: logger.error(f" ì—°ì† ì‹¤íŒ¨ ê²€ì‚¬ ì‹¤íŒ¨: {e}") return None def check_new_data_available(self, new_data_count: int, last_retrain_date: str) -> Optional[RetrainTrigger]: """ìƒˆ ë°ì´í„° ê°€ìš©ì„± ê²€ì‚¬""" try: threshold = self.config.get("retrain_conditions", {}).get("data_volume_threshold", 1000) if new_data_count >= threshold: severity = self._determine_severity(new_data_count / threshold) trigger = RetrainTrigger( trigger_type=RetrainTriggerType.NEW_DATA_AVAILABLE, threshold_value=threshold, current_value=new_data_count, severity=severity, description=f"ìƒˆ ë°ì´í„° ì¶©ë¶„: {new_data_count}ê°œ (ì„ê³„ê°’: {threshold}ê°œ)", triggered_at=datetime.now().isoformat(), metadata={ "new_data_count": new_data_count, "last_retrain_date": last_retrain_date } ) logger.info(f"â„¹ï¸ ìƒˆ ë°ì´í„° íŠ¸ë¦¬ê±°: {trigger.description}") return trigger return None except Exception as e: logger.error(f" ìƒˆ ë°ì´í„° ê²€ì‚¬ ì‹¤íŒ¨: {e}") return None def check_scheduled_retrain(self, last_retrain_date: str) -> Optional[RetrainTrigger]: """ì •ê¸° ì¬í•™ìŠµ ê²€ì‚¬""" try: if not last_retrain_date: return None last_retrain = datetime.fromisoformat(last_retrain_date) interval_days = self.config.get("retrain_conditions", {}).get("scheduled_interval_days", 30) next_retrain = last_retrain + timedelta(days=interval_days) if datetime.now() >= next_retrain: trigger = RetrainTrigger( trigger_type=RetrainTriggerType.SCHEDULED_RETRAIN, threshold_value=interval_days, current_value=(datetime.now() - last_retrain).days, severity="medium", description=f"ì •ê¸° ì¬í•™ìŠµ ì‹œì : {interval_days}ì¼ ê²½ê³¼", triggered_at=datetime.now().isoformat(), metadata={ "last_retrain_date": last_retrain_date, "interval_days": interval_days } ) logger.info(f"â„¹ï¸ ì •ê¸° ì¬í•™ìŠµ íŠ¸ë¦¬ê±°: {trigger.description}") return trigger return None except Exception as e: logger.error(f" ì •ê¸° ì¬í•™ìŠµ ê²€ì‚¬ ì‹¤íŒ¨: {e}") return None def _calculate_historical_average(self, historical_data: List[Dict]) -> Dict: """ê³¼ê±° í‰ê·  ê³„ì‚°""" try: if not historical_data: return {} # ëª¨ë“  í‚¤ ìˆ˜ì§‘ all_keys = set() for data in historical_data: all_keys.update(data.keys()) # í‰ê·  ê³„ì‚° averages = {} for key in all_keys: values = [data.get(key, 0) for data in historical_data if isinstance(data.get(key), (int, float))] if values: averages[key] = sum(values) / len(values) return averages except Exception as e: logger.error(f" ê³¼ê±° í‰ê·  ê³„ì‚° ì‹¤íŒ¨: {e}") return {} def _determine_severity(self, ratio: float) -> str: """ì‹¬ê°ë„ ê²°ì •""" try: if ratio >= 2.0: return "critical" elif ratio >= 1.5: return "high" elif ratio >= 1.0: return "medium" else: return "low" except Exception as e: logger.error(f" ì‹¬ê°ë„ ê²°ì • ì‹¤íŒ¨: {e}") return "low" def evaluate_all_triggers(self, current_metrics: Dict, historical_metrics: List[Dict], current_accuracy: Dict, historical_accuracy: List[Dict], failure_log: List[Dict], new_data_count: int, last_retrain_date: str) -> List[RetrainTrigger]: """ëª¨ë“  íŠ¸ë¦¬ê±° í‰ê°€""" try: triggers = [] # í’ˆì§ˆ ì €í•˜ ê²€ì‚¬ quality_trigger = self.check_quality_degradation(current_metrics, historical_metrics) if quality_trigger: triggers.append(quality_trigger) # ì •í™•ë„ í•˜ë½ ê²€ì‚¬ accuracy_trigger = self.check_accuracy_drop(current_accuracy, historical_accuracy) if accuracy_trigger: triggers.append(accuracy_trigger) # ì—°ì† ì‹¤íŒ¨ ê²€ì‚¬ failure_trigger = self.check_consecutive_failures(failure_log) if failure_trigger: triggers.append(failure_trigger) # ìƒˆ ë°ì´í„° ê²€ì‚¬ data_trigger = self.check_new_data_available(new_data_count, last_retrain_date) if data_trigger: triggers.append(data_trigger) # ì •ê¸° ì¬í•™ìŠµ ê²€ì‚¬ scheduled_trigger = self.check_scheduled_retrain(last_retrain_date) if scheduled_trigger: triggers.append(scheduled_trigger) # íŠ¸ë¦¬ê±° ì €ì¥ self.triggers.extend(triggers) # ì‹¬ê°ë„ë³„ ì •ë ¬ severity_order = {"critical": 4, "high": 3, "medium": 2, "low": 1} triggers.sort(key=lambda x: severity_order.get(x.severity, 0), reverse=True) logger.info(f" íŠ¸ë¦¬ê±° í‰ê°€ ì™„ë£Œ: {len(triggers)}ê°œ ë°œê²¬") return triggers except Exception as e: logger.error(f" íŠ¸ë¦¬ê±° í‰ê°€ ì‹¤íŒ¨: {e}") return [] def get_retrain_recommendation(self, triggers: List[RetrainTrigger]) -> Dict: """ì¬í•™ìŠµ ê¶Œì¥ì‚¬í•­ ìƒì„±""" try: if not triggers: return { "should_retrain": False, "priority": 0, "reason": "íŠ¸ë¦¬ê±° ì—†ìŒ" } # ìµœê³  ìš°ì„ ìˆœìœ„ íŠ¸ë¦¬ê±° highest_trigger = triggers[0] # ì¬í•™ìŠµ í•„ìš”ì„± íŒë‹¨ should_retrain = highest_trigger.severity in ["high", "critical"] # ìš°ì„ ìˆœìœ„ ê³„ì‚° severity_priority = {"critical": 4, "high": 3, "medium": 2, "low": 1} priority = severity_priority.get(highest_trigger.severity, 0) recommendation = { "should_retrain": should_retrain, "priority": priority, "reason": highest_trigger.description, "trigger_type": highest_trigger.trigger_type.value, "severity": highest_trigger.severity, "all_triggers": [ { "type": t.trigger_type.value, "severity": t.severity, "description": t.description } for t in triggers ] } logger.info(f" ì¬í•™ìŠµ ê¶Œì¥ì‚¬í•­: {recommendation['reason']}") return recommendation except Exception as e: logger.error(f" ì¬í•™ìŠµ ê¶Œì¥ì‚¬í•­ ìƒì„± ì‹¤íŒ¨: {e}") return {"should_retrain": False, "priority": 0, "reason": "ì˜¤ë¥˜ ë°œìƒ"} def send_slack_notification(self, triggers: List[RetrainTrigger], recommendation: Dict): """Slack ì•Œë¦¼ ì „ì†¡""" try: if not self.slack_webhook_url: logger.warning(" Slack Webhook URLì´ ì„¤ì •ë˜ì§€ ì•ŠìŒ") return False # ì•Œë¦¼ ë©”ì‹œì§€ êµ¬ì„± message = self._build_slack_message(triggers, recommendation) # Slack Webhook ì „ì†¡ response = requests.post( self.slack_webhook_url, json=message, timeout=10 ) if response.status_code == 200: logger.info(" Slack ì•Œë¦¼ ì „ì†¡ ì„±ê³µ") return True else: logger.error(f" Slack ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {response.status_code}") return False except Exception as e: logger.error(f" Slack ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") return False def _build_slack_message(self, triggers: List[RetrainTrigger], recommendation: Dict) -> Dict: """Slack ë©”ì‹œì§€ êµ¬ì„±""" try: # íŠ¸ë¦¬ê±° ìš”ì•½ trigger_summary = [] for trigger in triggers: severity_emoji = { 'low': 'ğŸŸ¡', 'medium': 'ğŸŸ ', 'high': 'ğŸ”´', 'critical': 'ğŸš¨' }.get(trigger.severity, 'âšª') trigger_summary.append( f"{severity_emoji} {trigger.trigger_type.value}: {trigger.description}" ) # ë©”ì‹œì§€ êµ¬ì„± message = { "text": " BrickBox ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì•Œë¦¼", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": " BrickBox ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì•Œë¦¼" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì¬í•™ìŠµ ê¶Œì¥:* {' ì˜ˆ' if recommendation['should_retrain'] else ' ì•„ë‹ˆì˜¤'}" }, { "type": "mrkdwn", "text": f"*ìš°ì„ ìˆœìœ„:* {recommendation['priority']}" }, { "type": "mrkdwn", "text": f"*ì‚¬ìœ :* {recommendation['reason']}" }, { "type": "mrkdwn", "text": f"*íŠ¸ë¦¬ê±° ìˆ˜:* {len(triggers)}ê°œ" } ] }, { "type": "section", "text": { "type": "mrkdwn", "text": f"*íŠ¸ë¦¬ê±° ìƒì„¸:*\n" + "\n".join(trigger_summary) } }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } return message except Exception as e: logger.error(f" Slack ë©”ì‹œì§€ êµ¬ì„± ì‹¤íŒ¨: {e}") return {"text": f"ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì•Œë¦¼: {e}"} def evaluate_all_triggers_with_notification(self) -> Dict: """ëª¨ë“  íŠ¸ë¦¬ê±° í‰ê°€ + ì•Œë¦¼ ì „ì†¡""" try: # íŠ¸ë¦¬ê±° í‰ê°€ triggers = self.evaluate_all_triggers() recommendation = self.get_retrain_recommendation() # Slack ì•Œë¦¼ ì „ì†¡ if triggers and recommendation.get('should_retrain'): self.send_slack_notification(triggers, recommendation) return { 'triggers': triggers, 'recommendation': recommendation, 'notification_sent': bool(triggers and recommendation.get('should_retrain')) } except Exception as e: logger.error(f" íŠ¸ë¦¬ê±° í‰ê°€ + ì•Œë¦¼ ì‹¤íŒ¨: {e}") return {'error': str(e)} def main(): """í…ŒìŠ¤íŠ¸ í•¨ìˆ˜""" try: # Retrain Trigger Manager ì´ˆê¸°í™” trigger_manager = RetrainTriggerManager("test_config/retrain_config.json") # í…ŒìŠ¤íŠ¸ ë°ì´í„° current_metrics = { "ssim": 0.90, # ì €í•˜ë¨ "snr": 25.0, # ì €í•˜ë¨ "sharpness": 0.65, # ì €í•˜ë¨ "noise_level": 0.20, # ì¦ê°€ë¨ "contrast": 0.25 # ì €í•˜ë¨ } historical_metrics = [ {"ssim": 0.97, "snr": 38.0, "sharpness": 0.85, "noise_level": 0.08, "contrast": 0.4}, {"ssim": 0.96, "snr": 36.0, "sharpness": 0.83, "noise_level": 0.09, "contrast": 0.38}, {"ssim": 0.95, "snr": 35.0, "sharpness": 0.82, "noise_level": 0.10, "contrast": 0.36} ] # íŠ¸ë¦¬ê±° í‰ê°€ triggers = trigger_manager.evaluate_all_triggers( current_metrics=current_metrics, historical_metrics=historical_metrics, current_accuracy={}, historical_accuracy=[], failure_log=[], new_data_count=0, last_retrain_date="2025-01-01T00:00:00" ) # ì¬í•™ìŠµ ê¶Œì¥ì‚¬í•­ recommendation = trigger_manager.get_retrain_recommendation(triggers) print(f"íŠ¸ë¦¬ê±° ìˆ˜: {len(triggers)}") print(f"ì¬í•™ìŠµ ê¶Œì¥: {recommendation['should_retrain']}") print(f"ìš°ì„ ìˆœìœ„: {recommendation['priority']}") print(f"ì‚¬ìœ : {recommendation['reason']}") return True except Exception as e: logger.error(f" í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}") return False if __name__ == "__main__": main() 