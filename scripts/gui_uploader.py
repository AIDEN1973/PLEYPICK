#!/usr/bin/env python3 """ BrickBox GUI Uploader (Windows) - 폴더 선택 → Supabase Storage(lego-synthetic) 업로드 - Service Role 또는 Anon Key 지원 """ import os import sys import threading import queue import time from pathlib import Path from typing import List, Dict from concurrent.futures import ThreadPoolExecutor import tkinter as tk from tkinter import ttk, filedialog, messagebox from supabase import create_client, Client # 하드코딩 기본값 (원하면 이 값을 직접 입력해 사용) # 주의: 배포/공용 PC에는 서비스 롤 키를 하드코딩하지 마세요. DEFAULT_SUPABASE_URL = "https://npferbxuxocbfnfbpcnz.supabase.co" DEFAULT_SERVICE_ROLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5wZmVyYnh1eG9jYmZuZmJwY256Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1OTQ3NDk4NSwiZXhwIjoyMDc1MDUwOTg1fQ.pPWhWrb4QBC-DT4dd6Y1p-LlHNd9UTKef3SHEXUDp00" DEFAULT_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5wZmVyYnh1eG9jYmZuZmJwY256Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0NzQ5ODUsImV4cCI6MjA3NTA1MDk4NX0.eqKQh_o1k2VmP-_v__gUMHVOgvdIzml-zDhZyzfxUmk" class BrickBoxGuiUploader: def __init__(self, root: tk.Tk) -> None: self.root = root self.root.title("BrickBox Uploader") self.root.geometry("760x560") self.root.resizable(True, True) # 상태 self.stop_flag = False self.total_files = 0 self.success_count = 0 self.fail_count = 0 self.failed_files = [] # 실패한 파일 목록 저장 self.msg_queue: "queue.Queue[str]" = queue.Queue() # UI self._build_ui() # 기본값 (하드코딩 > 환경변수 순서로 채움) self.var_url.set(DEFAULT_SUPABASE_URL or os.getenv("VITE_SUPABASE_URL", "")) self.var_service_key.set(DEFAULT_SERVICE_ROLE_KEY or os.getenv("SUPABASE_SERVICE_ROLE_KEY", "")) self.var_anon_key.set(DEFAULT_ANON_KEY or os.getenv("VITE_SUPABASE_ANON_KEY", "")) def _build_ui(self) -> None: p = ttk.Frame(self.root, padding=12) p.pack(fill=tk.BOTH, expand=True) # 메뉴바 및 단축키 menubar = tk.Menu(self.root) menu_upload = tk.Menu(menubar, tearoff=0) menu_upload.add_command(label="업로드 시작 Ctrl+U", command=self.start_upload) menu_upload.add_command(label="중지 Ctrl+.", command=self.stop_upload) menubar.add_cascade(label="작업", menu=menu_upload) self.root.config(menu=menubar) self.root.bind_all("<Control-u>", lambda e: self.start_upload()) self.root.bind_all("<Control-period>", lambda e: self.stop_upload()) # 상단 툴바 (버튼이 가려지는 환경 대비) toolbar = ttk.Frame(p) toolbar.pack(fill=tk.X, pady=(0, 8)) ttk.Button(toolbar, text="업로드 시작", command=self.start_upload).pack(side=tk.LEFT) ttk.Button(toolbar, text="중지", command=self.stop_upload).pack(side=tk.LEFT, padx=6) ttk.Button(toolbar, text="실패 파일만 재업로드", command=self.retry_failed_uploads).pack(side=tk.LEFT, padx=6) ttk.Button(toolbar, text="실패 목록 저장", command=self.save_failed_list).pack(side=tk.LEFT, padx=6) ttk.Button(toolbar, text="동기화", command=self.sync_database).pack(side=tk.LEFT, padx=12) ttk.Button(toolbar, text="동기화 재시도", command=self.retry_sync).pack(side=tk.LEFT, padx=6) ttk.Button(toolbar, text="실패 업로드 목록", command=self.show_upload_failures).pack(side=tk.LEFT, padx=12) ttk.Button(toolbar, text="실패 동기화 목록", command=self.show_sync_failures).pack(side=tk.LEFT, padx=6) # Supabase 설정 supa_frame = ttk.LabelFrame(p, text="Supabase 설정") supa_frame.pack(fill=tk.X) ttk.Label(supa_frame, text="URL").grid(row=0, column=0, sticky=tk.W, pady=4) self.var_url = tk.StringVar() ttk.Entry(supa_frame, textvariable=self.var_url, width=72).grid(row=0, column=1, sticky=tk.W) ttk.Label(supa_frame, text="Service Role Key (권장)").grid(row=1, column=0, sticky=tk.W, pady=4) self.var_service_key = tk.StringVar() ttk.Entry(supa_frame, textvariable=self.var_service_key, width=72, show="*").grid(row=1, column=1, sticky=tk.W) ttk.Label(supa_frame, text="Anon Key (선택)").grid(row=2, column=0, sticky=tk.W, pady=4) self.var_anon_key = tk.StringVar() ttk.Entry(supa_frame, textvariable=self.var_anon_key, width=72, show="*").grid(row=2, column=1, sticky=tk.W) # 대상 폴더/옵션 target_frame = ttk.LabelFrame(p, text="업로드 설정") target_frame.pack(fill=tk.X, pady=(8, 0)) ttk.Label(target_frame, text="대상 폴더").grid(row=0, column=0, sticky=tk.W) self.var_folder = tk.StringVar(value=r"C:\cursor\brickbox\output\synthetic") ttk.Entry(target_frame, textvariable=self.var_folder, width=64).grid(row=0, column=1, sticky=tk.W) ttk.Button(target_frame, text="찾기", command=self._choose_folder).grid(row=0, column=2, padx=6) ttk.Label(target_frame, text="배치 크기").grid(row=1, column=0, sticky=tk.W, pady=(6, 0)) self.var_batch = tk.IntVar(value=24) ttk.Spinbox(target_frame, from_=1, to=100, textvariable=self.var_batch, width=8).grid(row=1, column=1, sticky=tk.W, pady=(6, 0)) ttk.Label(target_frame, text="동시 업로드").grid(row=2, column=0, sticky=tk.W, pady=(6, 0)) self.var_concurrent = tk.IntVar(value=6) ttk.Spinbox(target_frame, from_=1, to=32, textvariable=self.var_concurrent, width=8).grid(row=2, column=1, sticky=tk.W, pady=(6, 0)) # 포함 파일 타입 옵션 opt_frame = ttk.Frame(target_frame) opt_frame.grid(row=3, column=0, columnspan=3, sticky=tk.W, pady=(8, 0)) self.var_include_image = tk.BooleanVar(value=True) self.var_include_txt = tk.BooleanVar(value=True) self.var_include_json = tk.BooleanVar(value=True) ttk.Checkbutton(opt_frame, text="이미지", variable=self.var_include_image).pack(side=tk.LEFT) ttk.Checkbutton(opt_frame, text="TXT(주석)", variable=self.var_include_txt).pack(side=tk.LEFT, padx=(12,0)) ttk.Checkbutton(opt_frame, text="JSON(메타)", variable=self.var_include_json).pack(side=tk.LEFT, padx=(12,0)) # 중복 처리 옵션 dup_frame = ttk.Frame(target_frame) dup_frame.grid(row=3, column=0, columnspan=3, sticky=tk.W, pady=(8, 0)) ttk.Label(dup_frame, text="중복 파일 처리:").pack(side=tk.LEFT) self.var_duplicate_action = tk.StringVar(value="ask") ttk.Radiobutton(dup_frame, text="물어보기", variable=self.var_duplicate_action, value="ask").pack(side=tk.LEFT, padx=(8,0)) ttk.Radiobutton(dup_frame, text="덮어쓰기", variable=self.var_duplicate_action, value="overwrite").pack(side=tk.LEFT, padx=(8,0)) ttk.Radiobutton(dup_frame, text="건너뛰기", variable=self.var_duplicate_action, value="skip").pack(side=tk.LEFT, padx=(8,0)) # 진행/로그 prog_frame = ttk.LabelFrame(p, text="진행 상태") prog_frame.pack(fill=tk.BOTH, expand=True, pady=(8, 0)) self.progress = ttk.Progressbar(prog_frame, maximum=100) self.progress.pack(fill=tk.X, pady=6) self.lbl_status = ttk.Label(prog_frame, text="대기 중") self.lbl_status.pack(anchor=tk.W) self.txt_log = tk.Text(prog_frame, height=10) self.txt_log.pack(fill=tk.BOTH, expand=True) # 버튼 btn_frame = ttk.Frame(p) btn_frame.pack(fill=tk.X, pady=8) ttk.Button(btn_frame, text="업로드 시작", command=self.start_upload).pack(side=tk.LEFT) ttk.Button(btn_frame, text="중지", command=self.stop_upload).pack(side=tk.LEFT, padx=6) ttk.Button(btn_frame, text="동기화", command=self.sync_database).pack(side=tk.LEFT, padx=12) ttk.Button(btn_frame, text="동기화 재시도", command=self.retry_sync).pack(side=tk.LEFT, padx=6) ttk.Button(btn_frame, text="실패 업로드 목록", command=self.show_upload_failures).pack(side=tk.LEFT, padx=12) ttk.Button(btn_frame, text="실패 동기화 목록", command=self.show_sync_failures).pack(side=tk.LEFT, padx=6) # 로그 폴링 self.root.after(100, self._drain_log) def _choose_folder(self) -> None: d = filedialog.askdirectory(title="업로드할 상위 폴더 선택") if d: self.var_folder.set(d) def log(self, msg: str) -> None: self.msg_queue.put(msg) def _drain_log(self) -> None: try: while True: msg = self.msg_queue.get_nowait() self.txt_log.insert(tk.END, msg + "\n") self.txt_log.see(tk.END) except queue.Empty: pass finally: self.root.after(100, self._drain_log) def _scan_files(self, base: Path) -> List[Dict]: items: List[Dict] = [] for part_folder in base.iterdir(): if not part_folder.is_dir(): continue part_id = part_folder.name # 스템별 그룹핑: 같은 접두명의 webp/png/jpg/txt/json을 묶어서 순차 업로드 stems: Dict[str, Dict[str, Path]] = {} for p in part_folder.iterdir(): if not p.is_file(): continue lower = p.name.lower() stem = p.stem if stem not in stems: stems[stem] = {} if lower.endswith(".webp"): stems[stem]["image"] = p elif lower.endswith(".png"): stems[stem]["image_png"] = p elif lower.endswith(".jpg") or lower.endswith(".jpeg"): stems[stem]["image_jpg"] = p elif lower.endswith(".txt"): stems[stem]["annotation"] = p elif lower.endswith(".json"): stems[stem]["json"] = p # 정렬: 파일명 자연 정렬을 위해 stem 키 정렬 for stem in sorted(stems.keys()): group = stems[stem] # 이미지 우선, 그 다음 txt, json 순서로 같은 스템을 연달아 추가 (옵션 적용) if self.var_include_image.get() and "image" in group: items.append({"part_id": part_id, "file_path": str(group["image"]), "file_type": "image"}) elif self.var_include_image.get() and "image_png" in group: items.append({"part_id": part_id, "file_path": str(group["image_png"]), "file_type": "image"}) elif self.var_include_image.get() and "image_jpg" in group: items.append({"part_id": part_id, "file_path": str(group["image_jpg"]), "file_type": "image"}) if self.var_include_txt.get() and "annotation" in group: items.append({"part_id": part_id, "file_path": str(group["annotation"]), "file_type": "annotation"}) if self.var_include_json.get() and "json" in group: items.append({"part_id": part_id, "file_path": str(group["json"]), "file_type": "json"}) return items def _do_upload(self) -> None: try: self.stop_flag = False self.success_count = 0 self.fail_count = 0 supabase_url = self.var_url.get().strip() service_key = self.var_service_key.get().strip() anon_key = self.var_anon_key.get().strip() if not supabase_url: messagebox.showerror("오류", "Supabase URL을 입력하세요") return key = service_key or anon_key if not key: messagebox.showerror("오류", "Service Role Key 또는 Anon Key를 입력하세요") return self.log("[INFO] Supabase 클라이언트 초기화") supabase: Client = create_client(supabase_url, key) base_dir = Path(self.var_folder.get()) if not base_dir.exists(): messagebox.showerror("오류", f"폴더가 존재하지 않습니다: {base_dir}") return items = self._scan_files(base_dir) self.total_files = len(items) if self.total_files == 0: self.log("[WARN] 업로드할 파일이 없습니다") return # 디버깅: 스캔된 파일 목록 출력 self.log(f"[DEBUG] 스캔된 파일 목록:") for i, item in enumerate(items[:10]): # 처음 10개만 출력 self.log(f" {i+1}. {item['file_type']}: {os.path.basename(item['file_path'])}") if len(items) > 10: self.log(f" ... 및 {len(items)-10}개 더") # 타입별 카운트 cnt_img = sum(1 for x in items if x["file_type"] == "image") cnt_txt = sum(1 for x in items if x["file_type"] == "annotation") cnt_json = sum(1 for x in items if x["file_type"] == "json") self.log(f"[INFO] 업로드 대상: {self.total_files}개 (이미지 {cnt_img}, TXT {cnt_txt}, JSON {cnt_json})") batch_size = max(1, int(self.var_batch.get())) concurrent_uploads = max(1, int(self.var_concurrent.get())) for i in range(0, len(items), batch_size): if self.stop_flag: break batch = items[i:i+batch_size] self.log(f"[INFO] 배치 {(i//batch_size)+1} 처리 중 ({len(batch)}개, 동시 {concurrent_uploads}개)") # 병렬 업로드 실행 with ThreadPoolExecutor(max_workers=concurrent_uploads) as executor: futures = [] for it in batch: if self.stop_flag: break future = executor.submit(self._upload_single, supabase, it) futures.append(future) # 결과 수집 for future in futures: if self.stop_flag: break try: ok = future.result(timeout=30) # 30초 타임아웃 if ok: self.success_count += 1 else: self.fail_count += 1 self._update_progress() except Exception as e: self.log(f"[ERROR] 업로드 타임아웃: {e}") self.fail_count += 1 self._update_progress() self.log(f"[RESULT] 완료: 성공 {self.success_count}, 실패 {self.fail_count}") except Exception as e: self.log(f"[ERROR] 업로드 오류: {e}") finally: self._update_progress(final=True) def _upload_single(self, supabase: Client, it: Dict) -> bool: try: filename = os.path.basename(it["file_path"]) part_id = it["part_id"] supa_path = f"synthetic/{part_id}/{filename}" # 중복 파일 확인 try: existing_files = supabase.storage.from_("lego-synthetic").list(supa_path.split('/')[0] + '/' + supa_path.split('/')[1]) if existing_files and any(f.get('name') == filename for f in existing_files): action = self.var_duplicate_action.get() if action == "ask": result = messagebox.askyesnocancel( "중복 파일 발견", f"파일 '{filename}'이 이미 존재합니다.\n\n덮어쓰시겠습니까?\n\n예: 덮어쓰기\n아니오: 건너뛰기\n취소: 전체 중지" ) if result is True: action = "overwrite" elif result is False: action = "skip" else: self.stop_flag = True return False if action == "skip": self.log(f"[SKIP] {filename} (중복)") return True elif action == "overwrite": self.log(f"[OVERWRITE] {filename}") except: pass # 파일 확인 실패 시 계속 진행 with open(it["file_path"], "rb") as f: data = f.read() # Content-Type 결정 lower = filename.lower() if it["file_type"] == "image" and lower.endswith(".webp"): content_type = "image/webp" elif lower.endswith(".png"): content_type = "image/png" elif lower.endswith(".jpg") or lower.endswith(".jpeg"): content_type = "image/jpeg" elif lower.endswith(".json"): content_type = "application/json" else: content_type = "text/plain" # 재시도 로직 (지수 백오프) max_retries = 3 backoff = 0.2 for attempt in range(max_retries): try: res = supabase.storage.from_("lego-synthetic").upload( supa_path, data, file_options={"content-type": content_type, "upsert": "true", "cache-control": "public, max-age=31536000"} ) if hasattr(res, "error") and res.error: raise Exception(res.error) break except Exception as e: if attempt < max_retries - 1: time.sleep(backoff) backoff *= 2 continue else: self.log(f"[ERROR] {filename}: {e}") self.failed_files.append(it) # 실패한 파일 저장 return False self.log(f"[PASS] {filename}") return True except Exception as e: self.log(f"[ERROR] {filename}: {e}") self.failed_files.append(it) # 실패한 파일 저장 return False def _update_progress(self, final: bool = False) -> None: done = self.success_count + self.fail_count pct = int((done / self.total_files) * 100) if self.total_files else 0 self.progress["value"] = pct self.lbl_status.config(text=f"진행률: {pct}% (성공 {self.success_count} / 실패 {self.fail_count})") if final: if self.failed_files: failed_count = len(self.failed_files) result = messagebox.askyesno( "업로드 완료", f"업로드 완료\n성공: {self.success_count}\n실패: {failed_count}\n\n실패한 파일을 재업로드하시겠습니까?" ) if result: self.retry_failed_uploads() else: messagebox.showinfo("완료", f"업로드 완료\n성공: {self.success_count}\n실패: {self.fail_count}") def start_upload(self) -> None: self.txt_log.delete("1.0", tk.END) t = threading.Thread(target=self._do_upload, daemon=True) t.start() def stop_upload(self) -> None: self.stop_flag = True self.log("[INFO] 중지 요청") def retry_failed_uploads(self) -> None: """실패한 파일들만 재업로드""" if not self.failed_files: messagebox.showinfo("알림", "재업로드할 실패 파일이 없습니다.") return self.log(f"[INFO] 실패 파일 {len(self.failed_files)}개 재업로드 시작") self.txt_log.delete("1.0", tk.END) t = threading.Thread(target=self._do_retry_upload, daemon=True) t.start() def _do_retry_upload(self) -> None: """실패 파일 재업로드 실행""" try: self.stop_flag = False self.success_count = 0 self.fail_count = 0 retry_failed = [] # 재시도 중 실패한 파일들 supabase_url = self.var_url.get().strip() service_key = self.var_service_key.get().strip() anon_key = self.var_anon_key.get().strip() if not supabase_url: messagebox.showerror("오류", "Supabase URL을 입력하세요") return key = service_key or anon_key if not key: messagebox.showerror("오류", "Service Role Key 또는 Anon Key를 입력하세요") return self.log("[INFO] Supabase 클라이언트 초기화") supabase: Client = create_client(supabase_url, key) concurrent_uploads = max(1, int(self.var_concurrent.get())) self.total_files = len(self.failed_files) self.log(f"[INFO] 재업로드 대상: {self.total_files}개 파일 (동시 {concurrent_uploads}개)") # 병렬 재업로드 실행 with ThreadPoolExecutor(max_workers=concurrent_uploads) as executor: futures = [] for it in self.failed_files: if self.stop_flag: break future = executor.submit(self._upload_single, supabase, it) futures.append(future) # 결과 수집 for i, future in enumerate(futures): if self.stop_flag: break try: ok = future.result(timeout=30) if ok: self.success_count += 1 else: self.fail_count += 1 retry_failed.append(self.failed_files[i]) self._update_progress() except Exception as e: self.log(f"[ERROR] 재업로드 타임아웃: {e}") self.fail_count += 1 retry_failed.append(self.failed_files[i]) self._update_progress() # 실패 파일 목록 업데이트 self.failed_files = retry_failed self.log(f"[RESULT] 재업로드 완료: 성공 {self.success_count}, 실패 {self.fail_count}") except Exception as e: self.log(f"[ERROR] 재업로드 오류: {e}") finally: self._update_progress(final=True) def save_failed_list(self) -> None: """실패 파일 목록을 파일로 저장""" if not self.failed_files: messagebox.showinfo("알림", "저장할 실패 파일이 없습니다.") return try: from tkinter import filedialog import os # logs 폴더 생성 logs_dir = "logs" if not os.path.exists(logs_dir): os.makedirs(logs_dir) # 기본 파일명 timestamp = time.strftime("%Y%m%d_%H%M%S") default_filename = f"failed_uploads_{timestamp}.txt" default_path = os.path.join(logs_dir, default_filename) # 파일 저장 대화상자 file_path = filedialog.asksaveasfilename( title="실패 파일 목록 저장", defaultextension=".txt", filetypes=[("텍스트 파일", "*.txt"), ("모든 파일", "*.*")], initialvalue=default_path ) if file_path: with open(file_path, 'w', encoding='utf-8') as f: f.write(f"BrickBox 업로드 실패 파일 목록\n") f.write(f"생성 시간: {time.strftime('%Y-%m-%d %H:%M:%S')}\n") f.write(f"총 실패 파일 수: {len(self.failed_files)}\n") f.write("=" * 50 + "\n\n") for i, failed_file in enumerate(self.failed_files, 1): f.write(f"{i:3d}. {failed_file['file_path']}\n") f.write(f" Part ID: {failed_file['part_id']}\n") f.write(f" Type: {failed_file['file_type']}\n\n") self.log(f"[INFO] 실패 목록 저장됨: {file_path}") messagebox.showinfo("완료", f"실패 파일 목록이 저장되었습니다.\n{file_path}") except Exception as e: self.log(f"[ERROR] 실패 목록 저장 실패: {e}") messagebox.showerror("오류", f"실패 목록 저장 중 오류가 발생했습니다.\n{e}") # === 동기화 기능 === def _collect_part_folders(self) -> List[str]: base_dir = Path(self.var_folder.get()) if not base_dir.exists(): messagebox.showerror("오류", f"폴더가 존재하지 않습니다: {base_dir}") return [] return [p.name for p in base_dir.iterdir() if p.is_dir()] def sync_database(self) -> None: parts = self._collect_part_folders() if not parts: return self.log(f"[INFO] 동기화 대상 파트: {len(parts)}개 → {', '.join(parts[:10])}{' ...' if len(parts)>10 else ''}") t = threading.Thread(target=self._do_sync, args=(parts,), daemon=True) t.start() def _do_sync(self, parts: List[str]) -> None: try: supabase_url = self.var_url.get().strip() key = (self.var_service_key.get().strip() or self.var_anon_key.get().strip()) if not supabase_url or not key: messagebox.showerror("오류", "Supabase URL / Key를 입력하세요") return supabase: Client = create_client(supabase_url, key) failed_sync: List[str] = [] for part_id in parts: try: # 버킷 내 목록 조회 후 URL 생성 → DB 삽입 remote_folder = f"synthetic/{part_id}" files = supabase.storage.from_("lego-synthetic").list(remote_folder) if hasattr(files, 'error') and files.error: raise Exception(files.error) if not files: self.log(f"[SYNC] {part_id}: 파일 없음, 건너뜀") continue # 이미지/어노테이션 매칭을 위해 stem 기준 그룹핑 stems = {} for f in files: name = f.get('name') if not name: continue lower = name.lower() stem = name.rsplit('.', 1)[0] stems.setdefault(stem, {}) if lower.endswith('.png') or lower.endswith('.jpg') or lower.endswith('.jpeg') or lower.endswith('.webp'): stems[stem]['image'] = f elif lower.endswith('.txt'): stems[stem]['annotation'] = f elif lower.endswith('.json'): stems[stem]['json'] = f records = [] for stem, group in stems.items(): img = group.get('image') if not img: continue # 이미지는 필수 img_name = img['name'] img_url = supabase.storage.from_("lego-synthetic").getPublicUrl(f"{remote_folder}/{img_name}") ann = group.get('annotation') ann_name = ann['name'] if ann else None ann_url = None if ann_name: ann_url_data = supabase.storage.from_("lego-synthetic").getPublicUrl(f"{remote_folder}/{ann_name}") ann_url = ann_url_data.publicUrl records.append({ 'part_id': part_id, 'image_url': img_url.publicUrl, 'filename': img_name, 'file_size': img.get('size', 0), 'image_path': f"{remote_folder}/{img_name}", 'annotation_url': ann_url, 'annotation_path': f"{remote_folder}/{ann_name}" if ann_name else None, 'status': 'completed', 'upload_method': 'gui_sync' }) if not records: continue res = supabase.table('synthetic_dataset').insert(records).execute() if hasattr(res, 'error') and res.error: raise Exception(res.error) self.log(f"[SYNC] {part_id}: {len(records)}건 동기화") except Exception as e: self.log(f"[ERROR] 동기화 실패 {part_id}: {e}") failed_sync.append(part_id) # 실패 저장 self._last_failed_sync = failed_sync if failed_sync: messagebox.showwarning("동기화 일부 실패", f"실패 파트: {len(failed_sync)}개\n{', '.join(failed_sync[:10])}{' ...' if len(failed_sync)>10 else ''}") else: messagebox.showinfo("동기화 완료", "모든 파트 동기화 성공") except Exception as e: self.log(f"[ERROR] 동기화 오류: {e}") def retry_sync(self) -> None: failed = getattr(self, '_last_failed_sync', None) if not failed: messagebox.showinfo("알림", "재시도할 동기화 실패 파트가 없습니다.") return self.log(f"[INFO] 동기화 재시도 대상: {len(failed)}개") t = threading.Thread(target=self._do_sync, args=(failed,), daemon=True) t.start() def show_upload_failures(self) -> None: try: supabase_url = self.var_url.get().strip() key = (self.var_service_key.get().strip() or self.var_anon_key.get().strip()) if not supabase_url or not key: messagebox.showerror("오류", "Supabase URL / Key를 입력하세요") return supabase: Client = create_client(supabase_url, key) res = supabase.table('synthetic_upload_failures').select('*').order('last_attempt_at', {'ascending': False}).limit(200).execute() rows = res.data if hasattr(res, 'data') else [] if not rows: messagebox.showinfo("실패 업로드", "실패 업로드 기록이 없습니다.") return self.txt_log.insert(tk.END, "\n[UPLOAD FAILURES]\n") for r in rows: self.txt_log.insert(tk.END, f"- {r.get('file_path')} | {r.get('error_message')} | retry={r.get('retry_count')}\n") self.txt_log.see(tk.END) except Exception as e: messagebox.showerror("오류", f"실패 업로드 목록 조회 실패: {e}") def show_sync_failures(self) -> None: try: supabase_url = self.var_url.get().strip() key = (self.var_service_key.get().strip() or self.var_anon_key.get().strip()) if not supabase_url or not key: messagebox.showerror("오류", "Supabase URL / Key를 입력하세요") return supabase: Client = create_client(supabase_url, key) res = supabase.table('synthetic_sync_failures').select('*').order('last_attempt_at', {'ascending': False}).limit(200).execute() rows = res.data if hasattr(res, 'data') else [] if not rows: messagebox.showinfo("실패 동기화", "실패 동기화 기록이 없습니다.") return self.txt_log.insert(tk.END, "\n[SYNC FAILURES]\n") for r in rows: self.txt_log.insert(tk.END, f"- {r.get('part_id')}/{r.get('filename')} | {r.get('error_message')} | retry={r.get('retry_count')}\n") self.txt_log.see(tk.END) except Exception as e: messagebox.showerror("오류", f"실패 동기화 목록 조회 실패: {e}") def main() -> None: root = tk.Tk() app = BrickBoxGuiUploader(root) root.mainloop() if __name__ == "__main__": main() 