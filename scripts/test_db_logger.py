#!/usr/bin/env python3 """ BrickBox Test DB Logger pytest ê²°ê³¼ë¥¼ operation_logs í…Œì´ë¸”ì— ìë™ ì—…ë¡œë“œ """ import os import sys import json import pytest import subprocess from datetime import datetime from typing import Dict, List, Optional import logging # Supabase í´ë¼ì´ì–¸íŠ¸ import try: from supabase import create_client, Client SUPABASE_URL = os.environ.get("SUPABASE_URL") SUPABASE_KEY = os.environ.get("SUPABASE_KEY") if SUPABASE_URL and SUPABASE_KEY: supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY) else: supabase = None print(" Supabase í™˜ê²½ ë³€ìˆ˜ ì—†ìŒ - DB ë¡œê¹… ë¹„í™œì„±í™”") except ImportError: supabase = None print(" Supabase í´ë¼ì´ì–¸íŠ¸ ì—†ìŒ - DB ë¡œê¹… ë¹„í™œì„±í™”") logger = logging.getLogger(__name__) class TestDBLogger: """í…ŒìŠ¤íŠ¸ ê²°ê³¼ DB ë¡œê±°""" def __init__(self, supabase_client=None): self.supabase = supabase_client or supabase self.test_session_id = f"test_session_{datetime.now().strftime('%Y%m%d_%H%M%S')}" def log_test_results(self, test_results: Dict) -> bool: """í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ DBì— ì €ì¥""" try: if not self.supabase: logger.warning(" Supabase í´ë¼ì´ì–¸íŠ¸ ì—†ìŒ - DB ë¡œê¹… ê±´ë„ˆë›°ê¸°") return False # í…ŒìŠ¤íŠ¸ ê²°ê³¼ êµ¬ì¡°í™” log_entry = { "timestamp": datetime.now().isoformat(), "operation_type": "TEST_EXECUTION", "status": "SUCCESS" if test_results.get("passed", 0) > 0 else "FAILED", "worker": "pytest", "metadata": { "test_session_id": self.test_session_id, "total_tests": test_results.get("total", 0), "passed": test_results.get("passed", 0), "failed": test_results.get("failed", 0), "skipped": test_results.get("skipped", 0), "duration": test_results.get("duration", 0.0), "test_files": test_results.get("test_files", []), "coverage_percentage": test_results.get("coverage", 0.0), "pytest_version": test_results.get("pytest_version", "unknown") }, "duration_seconds": test_results.get("duration", 0.0), "error": None if test_results.get("failed", 0) == 0 else f"{test_results.get('failed', 0)} tests failed" } # operation_logs í…Œì´ë¸”ì— ì €ì¥ result = self.supabase.table('operation_logs').insert(log_entry).execute() if result.data: logger.info(f" í…ŒìŠ¤íŠ¸ ê²°ê³¼ DB ì €ì¥ ì™„ë£Œ: {self.test_session_id}") return True else: logger.error(f" í…ŒìŠ¤íŠ¸ ê²°ê³¼ DB ì €ì¥ ì‹¤íŒ¨: {result}") return False except Exception as e: logger.error(f" í…ŒìŠ¤íŠ¸ ê²°ê³¼ DB ì €ì¥ ì‹¤íŒ¨: {e}") return False def log_individual_test(self, test_name: str, status: str, duration: float, error_message: str = None, coverage_data: Dict = None) -> bool: """ê°œë³„ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì €ì¥""" try: if not self.supabase: return False log_entry = { "timestamp": datetime.now().isoformat(), "operation_type": "INDIVIDUAL_TEST", "status": status.upper(), "worker": "pytest", "metadata": { "test_session_id": self.test_session_id, "test_name": test_name, "duration": duration, "error_message": error_message, "coverage_data": coverage_data or {} }, "duration_seconds": duration, "error": error_message } result = self.supabase.table('operation_logs').insert(log_entry).execute() return bool(result.data) except Exception as e: logger.error(f" ê°œë³„ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {e}") return False def run_pytest_with_db_logging(test_path: str = "tests/", coverage: bool = True, verbose: bool = True) -> Dict: """pytest ì‹¤í–‰ ë° DB ë¡œê¹…""" try: # pytest ëª…ë ¹ì–´ êµ¬ì„± cmd = ["python", "-m", "pytest", test_path] if verbose: cmd.append("-v") if coverage: cmd.extend(["--cov=scripts", "--cov-report=json", "--cov-report=term"]) # pytest ì‹¤í–‰ print(f" pytest ì‹¤í–‰: {' '.join(cmd)}") result = subprocess.run(cmd, capture_output=True, text=True, cwd=os.getcwd()) # ê²°ê³¼ íŒŒì‹± test_results = { "total": 0, "passed": 0, "failed": 0, "skipped": 0, "duration": 0.0, "test_files": [], "coverage": 0.0, "pytest_version": "unknown", "stdout": result.stdout, "stderr": result.stderr, "return_code": result.returncode } # stdoutì—ì„œ ê²°ê³¼ íŒŒì‹± lines = result.stdout.split('\n') for line in lines: if "passed" in line and "failed" in line: # ì˜ˆ: "3 passed, 1 failed in 2.34s" parts = line.split() for i, part in enumerate(parts): if part.isdigit(): if "passed" in line and i > 0 and parts[i-1] == part: test_results["passed"] = int(part) elif "failed" in line and i > 0 and parts[i-1] == part: test_results["failed"] = int(part) elif "skipped" in line and i > 0 and parts[i-1] == part: test_results["skipped"] = int(part) if "TOTAL" in line and "COVERAGE" in line: # ì»¤ë²„ë¦¬ì§€ ì •ë³´ íŒŒì‹± try: coverage_str = line.split()[-1].replace('%', '') test_results["coverage"] = float(coverage_str) except: pass # í…ŒìŠ¤íŠ¸ íŒŒì¼ ëª©ë¡ ìˆ˜ì§‘ test_files = [] for line in lines: if line.startswith("tests/") and ".py" in line: test_files.append(line.split()[0]) test_results["test_files"] = test_files # ì´ í…ŒìŠ¤íŠ¸ ìˆ˜ ê³„ì‚° test_results["total"] = test_results["passed"] + test_results["failed"] + test_results["skipped"] # DBì— ê²°ê³¼ ì €ì¥ db_logger = TestDBLogger() db_logger.log_test_results(test_results) print(f" í…ŒìŠ¤íŠ¸ ì™„ë£Œ: {test_results['passed']} passed, {test_results['failed']} failed") if coverage: print(f" ì»¤ë²„ë¦¬ì§€: {test_results['coverage']:.1f}%") return test_results except Exception as e: logger.error(f" pytest ì‹¤í–‰ ì‹¤íŒ¨: {e}") return {"error": str(e)} def main(): """í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° DB ë¡œê¹… ë©”ì¸ í•¨ìˆ˜""" try: print("ğŸ§ª BrickBox í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° DB ë¡œê¹… ì‹œì‘") # í…ŒìŠ¤íŠ¸ ì‹¤í–‰ test_results = run_pytest_with_db_logging( test_path="tests/", coverage=True, verbose=True ) if "error" in test_results: print(f" í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: {test_results['error']}") return False # ê²°ê³¼ ìš”ì•½ print(f"\n í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½:") print(f"ì´ í…ŒìŠ¤íŠ¸: {test_results['total']}") print(f"ì„±ê³µ: {test_results['passed']}") print(f"ì‹¤íŒ¨: {test_results['failed']}") print(f"ê±´ë„ˆë›°ê¸°: {test_results['skipped']}") print(f"ì»¤ë²„ë¦¬ì§€: {test_results['coverage']:.1f}%") print(f"ì‹¤í–‰ ì‹œê°„: {test_results['duration']:.2f}ì´ˆ") return test_results['failed'] == 0 except Exception as e: logger.error(f" í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: {e}") return False if __name__ == "__main__": success = main() sys.exit(0 if success else 1) 