#!/usr/bin/env python3 """ ğŸ“± BrickBox Slack ì•Œë¦¼ ì‹œìŠ¤í…œ notification_settings í…Œì´ë¸” ì—°ë™ + ìë™ ì•Œë¦¼ """ import os import sys import json import time import logging import requests from datetime import datetime, timedelta from typing import Dict, List, Optional from pathlib import Path # í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ Python ê²½ë¡œì— ì¶”ê°€ project_root = Path(__file__).parent.parent sys.path.append(str(project_root)) # ë¡œê¹… ì„¤ì • logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') logger = logging.getLogger(__name__) class SlackNotificationSystem: """Slack ì•Œë¦¼ ì‹œìŠ¤í…œ""" def __init__(self, supabase_client=None): self.supabase = supabase_client self.supabase_url = os.getenv('VITE_SUPABASE_URL') self.supabase_key = os.getenv('VITE_SUPABASE_SERVICE_ROLE') self.notification_settings = {} # ê¸°ë³¸ ì•Œë¦¼ ì„¤ì • self.default_settings = { 'training_start': True, 'training_complete': True, 'training_failure': True, 'retrain_trigger': True, 'slo_violation': True, 'quality_degradation': True, 'system_error': True } def load_notification_settings(self): """notification_settings í…Œì´ë¸”ì—ì„œ ì„¤ì • ë¡œë“œ""" try: if not self.supabase: logger.warning(" Supabase ì—°ê²° ì—†ìŒ - ê¸°ë³¸ ì„¤ì • ì‚¬ìš©") self.notification_settings = self.default_settings return # notification_settings ì¡°íšŒ result = self.supabase.table('notification_settings').select('*').execute() if result.data: settings = result.data[0] self.notification_settings = { 'webhook_url': settings.get('webhook_url'), 'channel': settings.get('channel', '#brickbox-alerts'), 'training_start': settings.get('training_start', True), 'training_complete': settings.get('training_complete', True), 'training_failure': settings.get('training_failure', True), 'retrain_trigger': settings.get('retrain_trigger', True), 'slo_violation': settings.get('slo_violation', True), 'quality_degradation': settings.get('quality_degradation', True), 'system_error': settings.get('system_error', True) } logger.info(" ì•Œë¦¼ ì„¤ì • ë¡œë“œ ì™„ë£Œ") else: # ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™” self._create_default_settings() self.notification_settings = self.default_settings except Exception as e: logger.error(f" ì•Œë¦¼ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}") self.notification_settings = self.default_settings def _create_default_settings(self): """ê¸°ë³¸ ì•Œë¦¼ ì„¤ì • ìƒì„±""" try: default_data = { 'webhook_url': os.getenv('SLACK_WEBHOOK_URL', ''), 'channel': '#brickbox-alerts', 'training_start': True, 'training_complete': True, 'training_failure': True, 'retrain_trigger': True, 'slo_violation': True, 'quality_degradation': True, 'system_error': True, 'created_at': datetime.now().isoformat() } self.supabase.table('notification_settings').insert(default_data).execute() logger.info(" ê¸°ë³¸ ì•Œë¦¼ ì„¤ì • ìƒì„± ì™„ë£Œ") except Exception as e: logger.error(f" ê¸°ë³¸ ì•Œë¦¼ ì„¤ì • ìƒì„± ì‹¤íŒ¨: {e}") def send_training_start_notification(self, job_id: int, config: Dict): """í•™ìŠµ ì‹œì‘ ì•Œë¦¼""" try: if not self.notification_settings.get('training_start', True): return message = { "text": " BrickBox í•™ìŠµ ì‹œì‘", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": " BrickBox í•™ìŠµ ì‹œì‘" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì‘ì—… ID:* {job_id}" }, { "type": "mrkdwn", "text": f"*ì—í¬í¬:* {config.get('epochs', 100)}" }, { "type": "mrkdwn", "text": f"*ë°°ì¹˜ í¬ê¸°:* {config.get('batch_size', 16)}" }, { "type": "mrkdwn", "text": f"*ë””ë°”ì´ìŠ¤:* {config.get('device', 'cuda')}" } ] }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(f" í•™ìŠµ ì‹œì‘ ì•Œë¦¼ ì „ì†¡: ì‘ì—… ID {job_id}") except Exception as e: logger.error(f" í•™ìŠµ ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def send_training_complete_notification(self, job_id: int, results: Dict): """í•™ìŠµ ì™„ë£Œ ì•Œë¦¼""" try: if not self.notification_settings.get('training_complete', True): return stage1_metrics = results.get('stage1', {}).get('metrics', {}) stage2_metrics = results.get('stage2', {}).get('metrics', {}) message = { "text": " BrickBox í•™ìŠµ ì™„ë£Œ", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": " BrickBox í•™ìŠµ ì™„ë£Œ" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì‘ì—… ID:* {job_id}" }, { "type": "mrkdwn", "text": f"*1ì°¨ ëª¨ë¸ mAP50:* {stage1_metrics.get('mAP50', 0):.4f}" }, { "type": "mrkdwn", "text": f"*2ì°¨ ëª¨ë¸ mAP50:* {stage2_metrics.get('mAP50', 0):.4f}" }, { "type": "mrkdwn", "text": f"*í•™ìŠµ ì‹œê°„:* {self._calculate_training_time(results)}" } ] }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(f" í•™ìŠµ ì™„ë£Œ ì•Œë¦¼ ì „ì†¡: ì‘ì—… ID {job_id}") except Exception as e: logger.error(f" í•™ìŠµ ì™„ë£Œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def send_training_failure_notification(self, job_id: int, error_message: str): """í•™ìŠµ ì‹¤íŒ¨ ì•Œë¦¼""" try: if not self.notification_settings.get('training_failure', True): return message = { "text": " BrickBox í•™ìŠµ ì‹¤íŒ¨", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": " BrickBox í•™ìŠµ ì‹¤íŒ¨" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì‘ì—… ID:* {job_id}" }, { "type": "mrkdwn", "text": f"*ì˜¤ë¥˜:* {error_message[:200]}..." } ] }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(f" í•™ìŠµ ì‹¤íŒ¨ ì•Œë¦¼ ì „ì†¡: ì‘ì—… ID {job_id}") except Exception as e: logger.error(f" í•™ìŠµ ì‹¤íŒ¨ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def send_retrain_trigger_notification(self, triggers: List[Dict], recommendation: Dict): """ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì•Œë¦¼""" try: if not self.notification_settings.get('retrain_trigger', True): return # íŠ¸ë¦¬ê±° ìš”ì•½ trigger_summary = [] for trigger in triggers: severity_emoji = { 'low': 'ğŸŸ¡', 'medium': 'ğŸŸ ', 'high': 'ğŸ”´', 'critical': 'ğŸš¨' }.get(trigger.get('severity', 'low'), 'âšª') trigger_summary.append( f"{severity_emoji} {trigger.get('type', 'Unknown')}: {trigger.get('description', 'No description')}" ) message = { "text": " BrickBox ì¬í•™ìŠµ íŠ¸ë¦¬ê±°", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": " BrickBox ì¬í•™ìŠµ íŠ¸ë¦¬ê±°" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì¬í•™ìŠµ ê¶Œì¥:* {' ì˜ˆ' if recommendation.get('should_retrain') else ' ì•„ë‹ˆì˜¤'}" }, { "type": "mrkdwn", "text": f"*ìš°ì„ ìˆœìœ„:* {recommendation.get('priority', 'MEDIUM')}" }, { "type": "mrkdwn", "text": f"*ì‚¬ìœ :* {recommendation.get('reason', 'Unknown')}" }, { "type": "mrkdwn", "text": f"*íŠ¸ë¦¬ê±° ìˆ˜:* {len(triggers)}ê°œ" } ] }, { "type": "section", "text": { "type": "mrkdwn", "text": f"*íŠ¸ë¦¬ê±° ìƒì„¸:*\n" + "\n".join(trigger_summary) } }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(" ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì•Œë¦¼ ì „ì†¡") except Exception as e: logger.error(f" ì¬í•™ìŠµ íŠ¸ë¦¬ê±° ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def send_slo_violation_notification(self, violations: List[Dict]): """SLO ìœ„ë°˜ ì•Œë¦¼""" try: if not self.notification_settings.get('slo_violation', True): return violation_summary = [] for violation in violations: violation_summary.append( f"ğŸ”´ {violation.get('metric', 'Unknown')}: {violation.get('current_value', 0):.3f} " f"(ì„ê³„ê°’: {violation.get('threshold', 0):.3f})" ) message = { "text": "ğŸš¨ BrickBox SLO ìœ„ë°˜", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": "ğŸš¨ BrickBox SLO ìœ„ë°˜" } }, { "type": "section", "text": { "type": "mrkdwn", "text": f"*ìœ„ë°˜ í•­ëª© ({len(violations)}ê°œ):*\n" + "\n".join(violation_summary) } }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(" SLO ìœ„ë°˜ ì•Œë¦¼ ì „ì†¡") except Exception as e: logger.error(f" SLO ìœ„ë°˜ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def send_quality_degradation_notification(self, degradation_info: Dict): """í’ˆì§ˆ ì €í•˜ ì•Œë¦¼""" try: if not self.notification_settings.get('quality_degradation', True): return message = { "text": " BrickBox í’ˆì§ˆ ì €í•˜", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": " BrickBox í’ˆì§ˆ ì €í•˜" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì €í•˜ìœ¨:* {degradation_info.get('degradation_rate', 0):.3f}" }, { "type": "mrkdwn", "text": f"*í˜„ì¬ SSIM:* {degradation_info.get('current_ssim', 0):.3f}" }, { "type": "mrkdwn", "text": f"*ê¸°ì¤€ SSIM:* {degradation_info.get('baseline_ssim', 0):.3f}" }, { "type": "mrkdwn", "text": f"*ì˜í–¥ ìƒ˜í”Œ:* {degradation_info.get('affected_samples', 0)}ê°œ" } ] }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(" í’ˆì§ˆ ì €í•˜ ì•Œë¦¼ ì „ì†¡") except Exception as e: logger.error(f" í’ˆì§ˆ ì €í•˜ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def send_system_error_notification(self, error_info: Dict): """ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì•Œë¦¼""" try: if not self.notification_settings.get('system_error', True): return message = { "text": "ğŸ’¥ BrickBox ì‹œìŠ¤í…œ ì˜¤ë¥˜", "blocks": [ { "type": "header", "text": { "type": "plain_text", "text": "ğŸ’¥ BrickBox ì‹œìŠ¤í…œ ì˜¤ë¥˜" } }, { "type": "section", "fields": [ { "type": "mrkdwn", "text": f"*ì˜¤ë¥˜ ìœ í˜•:* {error_info.get('error_type', 'Unknown')}" }, { "type": "mrkdwn", "text": f"*ì˜¤ë¥˜ ë©”ì‹œì§€:* {error_info.get('error_message', 'No message')[:100]}..." }, { "type": "mrkdwn", "text": f"*ì»´í¬ë„ŒíŠ¸:* {error_info.get('component', 'Unknown')}" }, { "type": "mrkdwn", "text": f"*ì‹¬ê°ë„:* {error_info.get('severity', 'Unknown')}" } ] }, { "type": "context", "elements": [ { "type": "mrkdwn", "text": f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}" } ] } ] } self._send_slack_message(message) logger.info(" ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡") except Exception as e: logger.error(f" ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}") def _calculate_training_time(self, results: Dict) -> str: """í•™ìŠµ ì‹œê°„ ê³„ì‚°""" try: # stage1 + stage2 í•™ìŠµ ì‹œê°„ í•©ì‚° stage1_time = results.get('stage1', {}).get('training_time', 0) stage2_time = results.get('stage2', {}).get('training_time', 0) total_time = stage1_time + stage2_time if total_time > 0: hours = int(total_time // 3600) minutes = int((total_time % 3600) // 60) return f"{hours}h {minutes}m" else: return "N/A" except Exception as e: logger.error(f" í•™ìŠµ ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨: {e}") return "N/A" def _send_slack_message(self, message: Dict): """Slack ë©”ì‹œì§€ ì „ì†¡ (Rate Limit ì ìš©)""" try: webhook_url = self.notification_settings.get('webhook_url') if not webhook_url: logger.error(" Slack Webhook URLì´ ì„¤ì •ë˜ì§€ ì•ŠìŒ - ì•Œë¦¼ ì „ì†¡ ë¶ˆê°€") # ì‹œìŠ¤í…œ ì˜¤ë¥˜ë¡œ ë¡œì»¬ ë¡œê·¸ ê¸°ë¡ logger.error("ğŸ’¥ Slack ì•Œë¦¼ ì‹œìŠ¤í…œ ì˜¤ë¥˜: webhook_url ëˆ„ë½") return False # Rate Limit ì²´í¬ (ë™ì¼ ë©”ì‹œì§€ 5ë¶„ ë‚´ ì¤‘ë³µ ë°©ì§€) if self._is_rate_limited(message): logger.warning(" Rate Limit: ë™ì¼ ì•Œë¦¼ 5ë¶„ ë‚´ ì¤‘ë³µ ì „ì†¡ ì°¨ë‹¨") return False response = requests.post( webhook_url, json=message, timeout=10 ) if response.status_code == 200: logger.info(" Slack ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ") self._record_sent_message(message) return True else: logger.error(f" Slack ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {response.status_code}") return False except Exception as e: logger.error(f" Slack ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {e}") return False def _is_rate_limited(self, message: Dict) -> bool: """Rate Limit ì²´í¬ (ë™ì¼ ë©”ì‹œì§€ 5ë¶„ ë‚´ ì¤‘ë³µ ë°©ì§€)""" try: import time # ë©”ì‹œì§€ í•‘ê±°í”„ë¦°íŠ¸ ìƒì„± message_key = str(hash(str(message.get('text', '')))) current_time = time.time() # ê°„ë‹¨í•œ ë©”ëª¨ë¦¬ ê¸°ë°˜ Rate Limit (ì‹¤ì œë¡œëŠ” Redis ê¶Œì¥) if not hasattr(self, '_sent_messages'): self._sent_messages = {} # 5ë¶„(300ì´ˆ) ì´ë‚´ ì¤‘ë³µ ì²´í¬ if message_key in self._sent_messages: last_sent = self._sent_messages[message_key] if current_time - last_sent < 300: # 5ë¶„ return True return False except Exception as e: logger.error(f" Rate Limit ì²´í¬ ì‹¤íŒ¨: {e}") return False def _record_sent_message(self, message: Dict): """ì „ì†¡ëœ ë©”ì‹œì§€ ê¸°ë¡""" try: import time message_key = str(hash(str(message.get('text', '')))) current_time = time.time() if not hasattr(self, '_sent_messages'): self._sent_messages = {} self._sent_messages[message_key] = current_time except Exception as e: logger.error(f" ë©”ì‹œì§€ ê¸°ë¡ ì‹¤íŒ¨: {e}") def update_notification_settings(self, settings: Dict): """ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸""" try: if not self.supabase: logger.error(" Supabase ì—°ê²° ì—†ìŒ") return False # notification_settings ì—…ë°ì´íŠ¸ (ë‹¨ì¼í–‰) result = self.supabase.table('notification_settings').update(settings).eq('id', 'default').execute() if result.data: self.notification_settings.update(settings) logger.info(" ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ") return True else: logger.error(" ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨") return False except Exception as e: logger.error(f" ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}") return False def main(): """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜""" try: # Supabase í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” from supabase import create_client supabase_url = os.getenv('VITE_SUPABASE_URL') supabase_key = os.getenv('VITE_SUPABASE_SERVICE_ROLE') if not supabase_url or not supabase_key: logger.error(" Supabase í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.") return supabase = create_client(supabase_url, supabase_key) # Slack ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™” slack_system = SlackNotificationSystem(supabase) slack_system.load_notification_settings() # í…ŒìŠ¤íŠ¸ ì•Œë¦¼ ì „ì†¡ slack_system.send_system_error_notification({ 'error_type': 'Test', 'error_message': 'Slack ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸', 'component': 'notification_system', 'severity': 'low' }) logger.info(" Slack ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ") except Exception as e: logger.error(f" Slack ì•Œë¦¼ ì‹œìŠ¤í…œ ì‹¤í–‰ ì‹¤íŒ¨: {e}") if __name__ == "__main__": main() 