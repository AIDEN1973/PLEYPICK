#!/usr/bin/env python3 """ 기존 저장된 레고 세트들의 이미지를 WebP로 변환하는 스크립트 """ import os import sys import asyncio import aiohttp from supabase import create_client, Client from dotenv import load_dotenv # 환경 변수 로드 load_dotenv() # Supabase 클라이언트 설정 SUPABASE_URL = os.getenv('VITE_SUPABASE_URL') SUPABASE_KEY = os.getenv('VITE_SUPABASE_ANON_KEY') if not SUPABASE_URL or not SUPABASE_KEY: print("Supabase environment variables not set.") print("VITE_SUPABASE_URL과 VITE_SUPABASE_ANON_KEY를 확인하세요.") sys.exit(1) supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY) async def convert_set_to_webp(set_data): """세트 이미지를 WebP로 변환""" try: set_num = set_data['set_num'] set_img_url = set_data['set_img_url'] print(f"Starting conversion: {set_num}") # 1. 기존 WebP 파일 삭제 (있다면) webp_filename = f"{set_num}_set.webp" try: supabase.storage.from_('lego_sets_images').remove([webp_filename]) print(f"Deleting existing WebP file: {webp_filename}") except Exception as e: print(f"Failed to delete existing file (ignored): {e}") # 2. 원본 이미지 다운로드 async with aiohttp.ClientSession() as session: async with session.get(set_img_url) as response: if response.status != 200: print(f"Image download failed: {set_num} (status: {response.status})") return False image_data = await response.read() print(f"Image download completed: {set_num} ({len(image_data)} bytes)") # 3. WebP 변환 (Pillow 사용) from PIL import Image import io # 이미지 열기 img = Image.open(io.BytesIO(image_data)) # 크기 최적화 (최대 800px) max_size = 800 if img.width > max_size or img.height > max_size: ratio = min(max_size / img.width, max_size / img.height) new_width = int(img.width * ratio) new_height = int(img.height * ratio) img = img.resize((new_width, new_height), Image.Resampling.LANCZOS) print(f"Size adjusted: {img.width}x{img.height}") # WebP로 변환 (품질 60%) webp_buffer = io.BytesIO() img.save(webp_buffer, format='WebP', quality=60, optimize=True) webp_data = webp_buffer.getvalue() print(f"WebP conversion completed: {len(webp_data)} bytes (original: {len(image_data)} bytes)") print(f"Compression ratio: {((len(image_data) - len(webp_data)) / len(image_data) * 100):.1f}% reduction") # 4. Supabase Storage에 업로드 (lego_parts_images 버킷의 lego_sets_images 폴더에) file_path = f"lego_sets_images/{webp_filename}" result = supabase.storage.from_('lego_parts_images').upload( file_path, webp_data, file_options={"content-type": "image/webp", "upsert": "true"} ) if hasattr(result, 'error') and result.error: print(f"Upload failed: {result.error}") return False print(f"Upload completed: {webp_filename}") # 5. set_images 테이블에 메타데이터 저장 public_url = f"{SUPABASE_URL}/storage/v1/object/public/lego_parts_images/lego_sets_images/{webp_filename}" metadata_data = { 'set_num': set_num, 'original_url': set_img_url, 'supabase_url': public_url, 'file_path': webp_filename, 'file_name': webp_filename, 'set_id': set_data['id'] } # upsert로 저장 result = supabase.table('set_images').upsert( metadata_data, on_conflict='set_num', returning='minimal' ).execute() if result.data: print(f"Metadata saved: {set_num}") else: print(f"Metadata save failed: {set_num}") return True except Exception as e: print(f"Conversion failed: {set_num} - {e}") return False async def main(): """메인 함수""" print("Starting LEGO sets WebP conversion...") try: # 저장된 세트 목록 조회 result = supabase.table('lego_sets').select('*').execute() sets = result.data if not sets: print("No saved sets found.") return print(f"Found {len(sets)} sets total") # 각 세트 변환 success_count = 0 for i, set_data in enumerate(sets, 1): print(f"\n[{i}/{len(sets)}] Processing: {set_data['set_num']} - {set_data['name']}") if await convert_set_to_webp(set_data): success_count += 1 # API 제한 방지를 위한 대기 await asyncio.sleep(1) print(f"\nConversion completed!") print(f"Success: {success_count}") print(f"Failed: {len(sets) - success_count}") except Exception as e: print(f"Error occurred: {e}") if __name__ == "__main__": asyncio.run(main()) 