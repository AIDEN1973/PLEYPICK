#!/usr/bin/env python3 """ BrickBox Storage ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸ Supabase Storage ë²„í‚·ì˜ ìš©ëŸ‰ ì‚¬ìš©ëŸ‰ì„ ëª¨ë‹ˆí„°ë§í•˜ê³  í•©ì„± ë°ì´í„°ì…‹ ìƒì„± ê³„íšì— ë”°ë¥¸ ìš©ëŸ‰ ì˜ˆì¸¡ì„ ì œê³µí•©ë‹ˆë‹¤. """ import os import sys import json from pathlib import Path from typing import Dict, List, Optional from datetime import datetime # í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ Python ê²½ë¡œì— ì¶”ê°€ project_root = Path(__file__).parent.parent sys.path.append(str(project_root)) try: from supabase import create_client, Client from dotenv import load_dotenv SUPABASE_AVAILABLE = True except ImportError: print(" Supabase í´ë¼ì´ì–¸íŠ¸ë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”: pip install supabase python-dotenv") SUPABASE_AVAILABLE = False class StorageCapacityMonitor: """Storage ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ í´ë˜ìŠ¤""" def __init__(self, supabase_url: str = None, supabase_key: str = None, bucket_name: str = "lego-synthetic"): self.bucket_name = bucket_name self.supabase = None # Supabase í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” if SUPABASE_AVAILABLE and supabase_url and supabase_key: try: self.supabase = create_client(supabase_url, supabase_key) print(" Supabase í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì„±ê³µ") except Exception as e: print(f" Supabase ì—°ê²° ì‹¤íŒ¨: {e}") def get_bucket_usage(self) -> Dict: """ë²„í‚· ì‚¬ìš©ëŸ‰ ì¡°íšŒ""" if not self.supabase: return {'error': 'Supabase í´ë¼ì´ì–¸íŠ¸ ì—†ìŒ'} try: # Storage ê°ì²´ ëª©ë¡ ì¡°íšŒ result = self.supabase.storage.from_(self.bucket_name).list() if isinstance(result, dict) and result.get('error'): return {'error': f"ë²„í‚· ì¡°íšŒ ì‹¤íŒ¨: {result['error']}"} # resultê°€ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° ì§ì ‘ ì‚¬ìš© files = result if isinstance(result, list) else result.get('data', []) # ìš©ëŸ‰ ê³„ì‚° total_size = 0 file_count = 0 synthetic_count = 0 synthetic_size = 0 for file_info in files: if 'size' in file_info: size = file_info['size'] total_size += size file_count += 1 # í•©ì„± ë°ì´í„°ì…‹ íŒŒì¼ í™•ì¸ if 'synthetic' in file_info.get('name', ''): synthetic_count += 1 synthetic_size += size return { 'total_files': file_count, 'total_size_bytes': total_size, 'total_size_mb': round(total_size / (1024 * 1024), 2), 'total_size_gb': round(total_size / (1024 * 1024 * 1024), 2), 'synthetic_files': synthetic_count, 'synthetic_size_bytes': synthetic_size, 'synthetic_size_mb': round(synthetic_size / (1024 * 1024), 2), 'synthetic_size_gb': round(synthetic_size / (1024 * 1024 * 1024), 2) } except Exception as e: return {'error': f"ìš©ëŸ‰ ì¡°íšŒ ì‹¤íŒ¨: {e}"} def calculate_capacity_plan(self, parts_count: int, images_per_part: int) -> Dict: """ìš©ëŸ‰ ê³„íš ê³„ì‚°""" # ì´ë¯¸ì§€ í¬ê¸° ì¶”ì • (RGB WebP Q80, 640x640) estimated_image_size_kb = 75 # 50-100KB ì¤‘ê°„ê°’ estimated_annotation_size_kb = 0.1 # YOLO ì–´ë…¸í…Œì´ì…˜ total_images = parts_count * images_per_part total_files = total_images * 2 # ì´ë¯¸ì§€ + ì–´ë…¸í…Œì´ì…˜ # ìš©ëŸ‰ ê³„ì‚° total_size_bytes = total_images * (estimated_image_size_kb + estimated_annotation_size_kb) * 1024 total_size_mb = total_size_bytes / (1024 * 1024) total_size_gb = total_size_mb / 1024 # 100GB ë²„í‚· ê¸°ì¤€ ì‚¬ìš©ë¥  bucket_capacity_gb = 100 usage_percentage = (total_size_gb / bucket_capacity_gb) * 100 return { 'parts_count': parts_count, 'images_per_part': images_per_part, 'total_images': total_images, 'total_files': total_files, 'estimated_size_gb': round(total_size_gb, 2), 'bucket_capacity_gb': bucket_capacity_gb, 'usage_percentage': round(usage_percentage, 2), 'remaining_capacity_gb': round(bucket_capacity_gb - total_size_gb, 2), 'recommendation': self._get_recommendation(usage_percentage) } def _get_recommendation(self, usage_percentage: float) -> str: """ìš©ëŸ‰ ì‚¬ìš©ë¥ ì— ë”°ë¥¸ ê¶Œì¥ì‚¬í•­""" if usage_percentage < 50: return " ì•ˆì „í•œ ì‚¬ìš©ëŸ‰ì…ë‹ˆë‹¤. ì¶”ê°€ ë°ì´í„°ì…‹ ìƒì„± ê°€ëŠ¥" elif usage_percentage < 80: return " ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤. ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ê¶Œì¥" elif usage_percentage < 95: return "ğŸš¨ ë†’ì€ ì‚¬ìš©ëŸ‰ì…ë‹ˆë‹¤. ì¶”ê°€ ìƒì„± ì „ ìš©ëŸ‰ ì •ë¦¬ í•„ìš”" else: return " ìš©ëŸ‰ ë¶€ì¡±ì…ë‹ˆë‹¤. ê¸°ì¡´ ë°ì´í„° ì •ë¦¬ ë˜ëŠ” ë²„í‚· í™•ì¥ í•„ìš”" def get_optimization_suggestions(self, current_usage: Dict, planned_usage: Dict) -> List[str]: """ìš©ëŸ‰ ìµœì í™” ì œì•ˆ""" suggestions = [] # í˜„ì¬ ì‚¬ìš©ëŸ‰ ë¶„ì„ current_gb = current_usage.get('total_size_gb', 0) planned_gb = planned_usage.get('estimated_size_gb', 0) total_gb = current_gb + planned_gb if total_gb > 80: # 80GB ì´ˆê³¼ ì‹œ suggestions.append(" ì´ë¯¸ì§€ ì••ì¶• ìµœì í™”: WebP Q80 í’ˆì§ˆ ì„¤ì •ìœ¼ë¡œ ì´ë¯¸ ìµœì í™”ë¨") suggestions.append("ğŸ—‚ï¸ íŒŒì¼ ì •ë¦¬: ì˜¤ë˜ëœ í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚­ì œ") suggestions.append(" ì„ íƒì  ìƒì„±: ì¤‘ìš” ë¶€í’ˆë§Œ ìš°ì„  ìƒì„±") if total_gb > 90: # 90GB ì´ˆê³¼ ì‹œ suggestions.append(" ë°°ì¹˜ ì²˜ë¦¬: ë‹¨ê³„ë³„ ìƒì„±ìœ¼ë¡œ ìš©ëŸ‰ ê´€ë¦¬") suggestions.append("â˜ï¸ ì•„ì¹´ì´ë¸Œ: ì™„ë£Œëœ ë°ì´í„°ì…‹ì„ ë³„ë„ ì €ì¥ì†Œë¡œ ì´ë™") suggestions.append(" ë²„í‚· í™•ì¥: í•„ìš”ì‹œ Supabase Storage í”Œëœ ì—…ê·¸ë ˆì´ë“œ") return suggestions def generate_capacity_report(self, current_usage: Dict, planned_usage: Dict) -> str: """ìš©ëŸ‰ ë³´ê³ ì„œ ìƒì„±""" report = { 'timestamp': datetime.now().isoformat(), 'bucket_name': self.bucket_name, 'current_usage': current_usage, 'planned_usage': planned_usage, 'total_estimated_gb': current_usage.get('total_size_gb', 0) + planned_usage.get('estimated_size_gb', 0), 'optimization_suggestions': self.get_optimization_suggestions(current_usage, planned_usage) } # ë³´ê³ ì„œ ì €ì¥ report_path = project_root / "logs" / f"storage_capacity_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json" report_path.parent.mkdir(parents=True, exist_ok=True) with open(report_path, 'w', encoding='utf-8') as f: json.dump(report, f, indent=2, ensure_ascii=False) print(f" ìš©ëŸ‰ ë³´ê³ ì„œ ìƒì„±: {report_path}") return str(report_path) def main(): """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜""" import argparse parser = argparse.ArgumentParser(description='Storage ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§') parser.add_argument('--parts-count', type=int, default=100, help='ê³„íšëœ ë¶€í’ˆ ìˆ˜') parser.add_argument('--images-per-part', type=int, default=1000, help='ë¶€í’ˆë‹¹ ì´ë¯¸ì§€ ìˆ˜') parser.add_argument('--supabase-url', help='Supabase URL') parser.add_argument('--supabase-key', help='Supabase API Key') args = parser.parse_args() # í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ try: load_dotenv(project_root / "config" / "synthetic_dataset.env") if not args.supabase_url: args.supabase_url = os.getenv('VITE_SUPABASE_URL') if not args.supabase_key: args.supabase_key = os.getenv('VITE_SUPABASE_ANON_KEY') except: pass print(" BrickBox Storage ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§") print("=" * 50) # ëª¨ë‹ˆí„° ì´ˆê¸°í™” monitor = StorageCapacityMonitor( supabase_url=args.supabase_url, supabase_key=args.supabase_key ) # 1. í˜„ì¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ print(" í˜„ì¬ Storage ì‚¬ìš©ëŸ‰ ì¡°íšŒ ì¤‘...") current_usage = monitor.get_bucket_usage() if 'error' in current_usage: print(f" {current_usage['error']}") return False print(f" í˜„ì¬ ì‚¬ìš©ëŸ‰:") print(f" - ì´ íŒŒì¼: {current_usage['total_files']}ê°œ") print(f" - ì´ ìš©ëŸ‰: {current_usage['total_size_gb']}GB") print(f" - í•©ì„± ë°ì´í„°: {current_usage['synthetic_files']}ê°œ ({current_usage['synthetic_size_gb']}GB)") # 2. ê³„íšëœ ì‚¬ìš©ëŸ‰ ê³„ì‚° print(f"\n ê³„íšëœ ì‚¬ìš©ëŸ‰ ê³„ì‚°:") print(f" - ë¶€í’ˆ ìˆ˜: {args.parts_count}ê°œ") print(f" - ë¶€í’ˆë‹¹ ì´ë¯¸ì§€: {args.images_per_part}ì¥") planned_usage = monitor.calculate_capacity_plan(args.parts_count, args.images_per_part) print(f" - ì´ ì´ë¯¸ì§€: {planned_usage['total_images']}ì¥") print(f" - ì˜ˆìƒ ìš©ëŸ‰: {planned_usage['estimated_size_gb']}GB") print(f" - ë²„í‚· ì‚¬ìš©ë¥ : {planned_usage['usage_percentage']}%") print(f" - ê¶Œì¥ì‚¬í•­: {planned_usage['recommendation']}") # 3. ìµœì í™” ì œì•ˆ print(f"\n ìµœì í™” ì œì•ˆ:") suggestions = monitor.get_optimization_suggestions(current_usage, planned_usage) for suggestion in suggestions: print(f" - {suggestion}") # 4. ë³´ê³ ì„œ ìƒì„± report_path = monitor.generate_capacity_report(current_usage, planned_usage) print(f"\n ìš©ëŸ‰ ë¶„ì„ ì™„ë£Œ!") print(f" ë³´ê³ ì„œ: {report_path}") return True if __name__ == "__main__": success = main() sys.exit(0 if success else 1) 