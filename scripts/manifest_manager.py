#!/usr/bin/env python3 """ BrickBox Manifest Manager 각 단계 완료 시 manifest.json 생성 및 관리 """ import os import json import time from datetime import datetime from typing import Dict, List, Optional import logging logger = logging.getLogger(__name__) class ManifestManager: """다계층 Manifest 관리자""" def __init__(self, dataset_root: str, multi_layer: bool = True): self.dataset_root = dataset_root self.multi_layer = multi_layer if multi_layer: # 다계층 Manifest 구조 self.manifest_paths = { 'dataset': os.path.join(dataset_root, "dataset_manifest.json"), 'index': os.path.join(dataset_root, "index_manifest.json"), 'model': os.path.join(dataset_root, "model_manifest.json") } else: # 기존 단일 Manifest 구조 (하위 호환성) self.manifest_path = os.path.join(dataset_root, "manifest.json") def create_manifest(self, stage: str, version: str, status: str, metadata: Dict = None) -> Dict: """다계층 Manifest 생성""" try: if self.multi_layer: return self._create_multi_layer_manifest(stage, version, status, metadata) else: return self._create_single_manifest(stage, version, status, metadata) except Exception as e: logger.error(f" Manifest 생성 실패: {e}") return None def _create_multi_layer_manifest(self, stage: str, version: str, status: str, metadata: Dict = None) -> Dict: """다계층 Manifest 생성""" try: # Dataset Manifest (데이터셋 레벨 정보) dataset_manifest = { "dataset_info": { "name": "BrickBox Synthetic Dataset", "version": version, "created_at": datetime.now().isoformat(), "updated_at": datetime.now().isoformat(), "total_parts": metadata.get("total_parts", 0), "dataset_size": metadata.get("dataset_size", "0MB") }, "pipeline_stages": { "rendering": {"status": "pending", "version": "0.0", "updated_at": None}, "embedding": {"status": "pending", "version": "0.0", "updated_at": None}, "fusion": {"status": "pending", "version": "0.0", "updated_at": None}, "qa": {"status": "pending", "version": "0.0", "updated_at": None} }, "current_stage": stage, "overall_status": "in_progress" } # Index Manifest (인덱스 레벨 정보) index_manifest = { "index_info": { "faiss_index_version": "0.0", "clip_vectors_count": 0, "fgc_vectors_count": 0, "index_size": "0MB", "created_at": datetime.now().isoformat(), "updated_at": datetime.now().isoformat() }, "search_performance": { "stage1_p95_latency": 0.0, "stage2_p95_latency": 0.0, "stage2_entry_rate": 0.0, "confusion_coverage": 0.0 } } # Model Manifest (모델 레벨 정보) model_manifest = { "model_info": { "detector_version": "0.0", "clip_model_version": "0.0", "fgc_model_version": "0.0", "fusion_weights": { "w_img": 0.5, "w_meta": 0.3, "w_txt": 0.2 }, "created_at": datetime.now().isoformat(), "updated_at": datetime.now().isoformat() }, "performance_metrics": { "detection_recall": 0.0, "identification_top1": 0.0, "false_positive_rate": 0.0, "holdout_rate": 0.0 } } # 각 Manifest 파일 저장 self._save_manifest_file('dataset', dataset_manifest) self._save_manifest_file('index', index_manifest) self._save_manifest_file('model', model_manifest) logger.info(" 다계층 Manifest 생성 완료") return { "dataset": dataset_manifest, "index": index_manifest, "model": model_manifest } except Exception as e: logger.error(f" 다계층 Manifest 생성 실패: {e}") return None def _save_manifest_file(self, manifest_type: str, manifest_data: Dict) -> bool: """개별 Manifest 파일 저장""" try: if not self.multi_layer: return False manifest_path = self.manifest_paths[manifest_type] os.makedirs(os.path.dirname(manifest_path), exist_ok=True) with open(manifest_path, 'w', encoding='utf-8') as f: json.dump(manifest_data, f, ensure_ascii=False, indent=2) logger.info(f" {manifest_type} Manifest 저장: {manifest_path}") return True except Exception as e: logger.error(f" {manifest_type} Manifest 저장 실패: {e}") return False def _load_manifest_file(self, manifest_type: str) -> Optional[Dict]: """개별 Manifest 파일 로드""" try: if not self.multi_layer: return None manifest_path = self.manifest_paths[manifest_type] if not os.path.exists(manifest_path): return None with open(manifest_path, 'r', encoding='utf-8') as f: manifest_data = json.load(f) return manifest_data except Exception as e: logger.error(f" {manifest_type} Manifest 로드 실패: {e}") return None def update_multi_layer_stage(self, stage: str, status: str, version: str, metadata: Dict = None) -> bool: """다계층 Manifest 단계 업데이트""" try: if not self.multi_layer: return False # Dataset Manifest 업데이트 dataset_manifest = self._load_manifest_file('dataset') if dataset_manifest and stage in dataset_manifest["pipeline_stages"]: dataset_manifest["pipeline_stages"][stage] = { "status": status, "version": version, "updated_at": datetime.now().isoformat(), "metadata": metadata or {} } dataset_manifest["updated_at"] = datetime.now().isoformat() self._save_manifest_file('dataset', dataset_manifest) # Index Manifest 업데이트 (embedding 단계인 경우) if stage == "embedding": index_manifest = self._load_manifest_file('index') if index_manifest: index_manifest["index_info"]["updated_at"] = datetime.now().isoformat() if metadata: index_manifest["index_info"]["clip_vectors_count"] = metadata.get("clip_vectors_count", 0) index_manifest["index_info"]["fgc_vectors_count"] = metadata.get("fgc_vectors_count", 0) index_manifest["index_info"]["index_size"] = metadata.get("index_size", "0MB") self._save_manifest_file('index', index_manifest) # Model Manifest 업데이트 (fusion 단계인 경우) if stage == "fusion": model_manifest = self._load_manifest_file('model') if model_manifest: model_manifest["model_info"]["updated_at"] = datetime.now().isoformat() if metadata: model_manifest["model_info"]["fusion_weights"] = metadata.get("fusion_weights", { "w_img": 0.5, "w_meta": 0.3, "w_txt": 0.2 }) self._save_manifest_file('model', model_manifest) logger.info(f" 다계층 Manifest 업데이트: {stage} -> {status}") return True except Exception as e: logger.error(f" 다계층 Manifest 업데이트 실패: {e}") return False def _create_single_manifest(self, stage: str, version: str, status: str, metadata: Dict = None) -> Dict: """단일 Manifest 생성 (하위 호환성)""" try: manifest = { "dataset_info": { "name": "BrickBox Synthetic Dataset", "version": version, "created_at": datetime.now().isoformat(), "updated_at": datetime.now().isoformat() }, "pipeline_stages": { "rendering": { "status": "pending", "version": "0.0", "updated_at": None, "metadata": {} }, "embedding": { "status": "pending", "version": "0.0", "updated_at": None, "metadata": {} }, "fusion": { "status": "pending", "version": "0.0", "updated_at": None, "metadata": {} }, "qa": { "status": "pending", "version": "0.0", "updated_at": None, "metadata": {} } }, "current_stage": stage, "overall_status": "in_progress" } # 현재 단계 업데이트 if stage in manifest["pipeline_stages"]: manifest["pipeline_stages"][stage] = { "status": status, "version": version, "updated_at": datetime.now().isoformat(), "metadata": metadata or {} } # 전체 상태 계산 stages = manifest["pipeline_stages"] completed_stages = sum(1 for s in stages.values() if s["status"] == "completed") total_stages = len(stages) if completed_stages == total_stages: manifest["overall_status"] = "completed" elif any(s["status"] == "failed" for s in stages.values()): manifest["overall_status"] = "failed" else: manifest["overall_status"] = "in_progress" return manifest except Exception as e: logger.error(f" Manifest 생성 실패: {e}") return {} def update_stage(self, stage: str, status: str, version: str, metadata: Dict = None) -> bool: """단계 상태 업데이트""" try: # 기존 manifest 로드 manifest = self.load_manifest() if not manifest: manifest = self.create_manifest(stage, version, status, metadata) else: # 단계 업데이트 if stage in manifest["pipeline_stages"]: manifest["pipeline_stages"][stage] = { "status": status, "version": version, "updated_at": datetime.now().isoformat(), "metadata": metadata or {} } # 전체 상태 재계산 stages = manifest["pipeline_stages"] completed_stages = sum(1 for s in stages.values() if s["status"] == "completed") total_stages = len(stages) if completed_stages == total_stages: manifest["overall_status"] = "completed" elif any(s["status"] == "failed" for s in stages.values()): manifest["overall_status"] = "failed" else: manifest["overall_status"] = "in_progress" # manifest 저장 return self.save_manifest(manifest) except Exception as e: logger.error(f" 단계 업데이트 실패: {e}") return False def load_manifest(self) -> Optional[Dict]: """Manifest 로드""" try: if not os.path.exists(self.manifest_path): return None with open(self.manifest_path, 'r', encoding='utf-8') as f: manifest = json.load(f) return manifest except Exception as e: logger.error(f" Manifest 로드 실패: {e}") return None def save_manifest(self, manifest: Dict) -> bool: """Manifest 저장""" try: os.makedirs(os.path.dirname(self.manifest_path), exist_ok=True) with open(self.manifest_path, 'w', encoding='utf-8') as f: json.dump(manifest, f, ensure_ascii=False, indent=2) logger.info(f" Manifest 저장: {self.manifest_path}") return True except Exception as e: logger.error(f" Manifest 저장 실패: {e}") return False def get_stage_status(self, stage: str) -> Optional[Dict]: """단계 상태 조회""" try: manifest = self.load_manifest() if not manifest or stage not in manifest["pipeline_stages"]: return None return manifest["pipeline_stages"][stage] except Exception as e: logger.error(f" 단계 상태 조회 실패: {e}") return None def get_overall_status(self) -> str: """전체 상태 조회""" try: manifest = self.load_manifest() if not manifest: return "not_started" return manifest.get("overall_status", "unknown") except Exception as e: logger.error(f" 전체 상태 조회 실패: {e}") return "error" def is_stage_completed(self, stage: str) -> bool: """단계 완료 여부 확인""" try: stage_status = self.get_stage_status(stage) return stage_status and stage_status["status"] == "completed" except Exception as e: logger.error(f" 단계 완료 확인 실패: {e}") return False def get_next_stage(self) -> Optional[str]: """다음 실행할 단계 조회""" try: manifest = self.load_manifest() if not manifest: return "rendering" # 첫 단계 stages = ["rendering", "embedding", "fusion", "qa"] for stage in stages: stage_status = manifest["pipeline_stages"][stage] if stage_status["status"] not in ["completed", "failed"]: return stage return None # 모든 단계 완료 except Exception as e: logger.error(f" 다음 단계 조회 실패: {e}") return None def main(): """다계층 Manifest 테스트 함수""" try: # 다계층 Manifest Manager 초기화 manager = ManifestManager("test_dataset", multi_layer=True) # 다계층 Manifest 생성 print(" 다계층 Manifest 생성 중...") manifest = manager.create_manifest("rendering", "1.0", "in_progress", { "total_parts": 1000, "dataset_size": "2.5GB" }) if manifest: print(" 다계층 Manifest 생성 완료") print(f"Dataset Manifest: {list(manifest['dataset'].keys())}") print(f"Index Manifest: {list(manifest['index'].keys())}") print(f"Model Manifest: {list(manifest['model'].keys())}") # 단계별 업데이트 테스트 print("\n 단계별 업데이트 테스트...") manager.update_multi_layer_stage("rendering", "completed", "1.0", {"images_count": 100}) manager.update_multi_layer_stage("embedding", "in_progress", "1.0", { "clip_vectors_count": 500, "fgc_vectors_count": 500, "index_size": "120MB" }) manager.update_multi_layer_stage("fusion", "pending", "1.0", { "fusion_weights": {"w_img": 0.6, "w_meta": 0.25, "w_txt": 0.15} }) # 상태 조회 print(f"\n 상태 조회:") print(f"전체 상태: {manager.get_overall_status()}") print(f"렌더링 완료: {manager.is_stage_completed('rendering')}") print(f"다음 단계: {manager.get_next_stage()}") # 개별 Manifest 파일 확인 print(f"\n[DIR] 생성된 Manifest 파일들:") for manifest_type, path in manager.manifest_paths.items(): if os.path.exists(path): print(f" {manifest_type}: {path}") else: print(f" {manifest_type}: {path} (파일 없음)") return True except Exception as e: logger.error(f" 테스트 실패: {e}") return False if __name__ == "__main__": main() 