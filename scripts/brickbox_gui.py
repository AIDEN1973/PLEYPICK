#!/usr/bin/env python3 """ BrickBox GUI 애플리케이션 Windows UI를 가진 설치형 프로그램 """ import tkinter as tk from tkinter import ttk, messagebox, filedialog, scrolledtext import threading import subprocess import os import sys from pathlib import Path import time from datetime import datetime class BrickBoxGUI: def __init__(self, root): self.root = root self.root.title("BrickBox Pipeline Manager") self.root.geometry("800x600") self.root.resizable(True, True) # 스타일 설정 self.setup_styles() # 변수 초기화 self.is_running = False self.process = None # UI 생성 self.create_widgets() # 상태 초기화 self.update_status("준비됨") def setup_styles(self): """스타일 설정""" style = ttk.Style() style.theme_use('clam') # 버튼 스타일 style.configure('Action.TButton', font=('맑은 고딕', 10, 'bold')) style.configure('Success.TButton', font=('맑은 고딕', 10, 'bold')) style.configure('Danger.TButton', font=('맑은 고딕', 10, 'bold')) def create_widgets(self): """UI 위젯 생성""" # 메인 프레임 main_frame = ttk.Frame(self.root, padding="10") main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S)) # 제목 title_label = ttk.Label(main_frame, text="BrickBox Pipeline Manager", font=('맑은 고딕', 16, 'bold')) title_label.grid(row=0, column=0, columnspan=3, pady=(0, 20)) # 상태 프레임 status_frame = ttk.LabelFrame(main_frame, text="상태", padding="10") status_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10)) self.status_label = ttk.Label(status_frame, text="준비됨", font=('맑은 고딕', 12)) self.status_label.grid(row=0, column=0, sticky=tk.W) self.progress = ttk.Progressbar(status_frame, mode='indeterminate') self.progress.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(5, 0)) # 제어 버튼 프레임 control_frame = ttk.LabelFrame(main_frame, text="제어", padding="10") control_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10)) # 버튼들 self.start_btn = ttk.Button(control_frame, text="파이프라인 시작", command=self.start_pipeline, style='Action.TButton') self.start_btn.grid(row=0, column=0, padx=(0, 10), pady=5) self.stop_btn = ttk.Button(control_frame, text="중지", command=self.stop_pipeline, style='Danger.TButton', state='disabled') self.stop_btn.grid(row=0, column=1, padx=(0, 10), pady=5) self.clear_btn = ttk.Button(control_frame, text="로그 지우기", command=self.clear_log) self.clear_btn.grid(row=0, column=2, padx=(0, 10), pady=5) self.open_folder_btn = ttk.Button(control_frame, text="결과 폴더 열기", command=self.open_result_folder) self.open_folder_btn.grid(row=0, column=3, pady=5) # 로그 프레임 log_frame = ttk.LabelFrame(main_frame, text="실행 로그", padding="10") log_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10)) # 로그 텍스트 self.log_text = scrolledtext.ScrolledText(log_frame, height=15, width=80, font=('Consolas', 9)) self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S)) # 그리드 가중치 설정 self.root.columnconfigure(0, weight=1) self.root.rowconfigure(0, weight=1) main_frame.columnconfigure(0, weight=1) main_frame.rowconfigure(3, weight=1) log_frame.columnconfigure(0, weight=1) log_frame.rowconfigure(0, weight=1) status_frame.columnconfigure(0, weight=1) def log_message(self, message): """로그 메시지 추가""" timestamp = datetime.now().strftime("%H:%M:%S") self.log_text.insert(tk.END, f"[{timestamp}] {message}\n") self.log_text.see(tk.END) self.root.update_idletasks() def clear_log(self): """로그 지우기""" self.log_text.delete(1.0, tk.END) def update_status(self, status): """상태 업데이트""" self.status_label.config(text=status) self.root.update_idletasks() def start_pipeline(self): """파이프라인 시작""" if self.is_running: self.log_message("이미 파이프라인이 실행 중입니다.") return self.is_running = True self.start_btn.config(state='disabled') self.stop_btn.config(state='normal') self.progress.start() # 백그라운드에서 실행 thread = threading.Thread(target=self.run_pipeline) thread.daemon = True thread.start() def stop_pipeline(self): """파이프라인 중지""" if self.process: self.process.terminate() self.log_message("파이프라인 중지 요청됨...") def run_pipeline(self): """파이프라인 실행 (백그라운드)""" try: self.log_message("BrickBox 파이프라인 시작...") self.update_status("실행 중...") # 렌더링 스크립트 실행 (새 창 없이) self.log_message("1단계: 렌더링 실행...") if sys.platform == "win32": self.process = subprocess.Popen([ sys.executable, "scripts/render_ldraw_to_supabase.py" ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', creationflags=subprocess.CREATE_NO_WINDOW) else: self.process = subprocess.Popen([ sys.executable, "scripts/render_ldraw_to_supabase.py" ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8') # 출력 실시간 표시 for line in iter(self.process.stdout.readline, ''): if line: self.log_message(f"렌더링: {line.strip()}") self.process.wait() if self.process.returncode == 0: self.log_message("렌더링 완료!") # 데이터셋 변환 실행 (새 창 없이) self.log_message("2단계: 데이터셋 변환...") if sys.platform == "win32": self.process = subprocess.Popen([ sys.executable, "scripts/prepare_training_dataset.py" ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', creationflags=subprocess.CREATE_NO_WINDOW) else: self.process = subprocess.Popen([ sys.executable, "scripts/prepare_training_dataset.py" ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8') for line in iter(self.process.stdout.readline, ''): if line: self.log_message(f"변환: {line.strip()}") self.process.wait() if self.process.returncode == 0: self.log_message("데이터셋 변환 완료!") self.log_message("파이프라인 성공적으로 완료!") self.update_status("완료") else: self.log_message(f"데이터셋 변환 실패 (코드: {self.process.returncode})") self.update_status("실패") else: self.log_message(f"렌더링 실패 (코드: {self.process.returncode})") self.update_status("실패") except Exception as e: self.log_message(f"오류 발생: {e}") self.update_status("오류") finally: self.is_running = False self.start_btn.config(state='normal') self.stop_btn.config(state='disabled') self.progress.stop() def open_result_folder(self): """결과 폴더 열기""" result_path = Path("data/brickbox_dataset") if result_path.exists(): os.startfile(str(result_path)) else: messagebox.showwarning("경고", "결과 폴더가 아직 생성되지 않았습니다.") def main(): """메인 함수""" root = tk.Tk() app = BrickBoxGUI(root) # 종료 시 처리 def on_closing(): if app.is_running: if messagebox.askokcancel("종료", "파이프라인이 실행 중입니다. 정말 종료하시겠습니까?"): if app.process: app.process.terminate() root.destroy() else: root.destroy() root.protocol("WM_DELETE_WINDOW", on_closing) root.mainloop() if __name__ == "__main__": main() 