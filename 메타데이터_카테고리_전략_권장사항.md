# 🎯 메타데이터 카테고리 전략 권장사항
## 폐쇄환경 누락 부품 검출 시스템 기준

**작성일**: 2025-10-13  
**시스템 목표**: 비전 기반 레고 세트 검수 (누락 부품 실시간 검출)  
**운영 환경**: 폐쇄환경 (오프라인 가능)

---

## 📊 시스템 아키텍처 분석

```
┌─────────────────────────────────────────────────────────┐
│  실시간 검출 시스템 (폐쇄환경)                            │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  카메라 → YOLO 검출 → 부품 식별 → BOM 비교 → 결과      │
│            ↓           ↓            ↓                     │
│         형태 인식   카테고리 분류  혼동 해소              │
│            ↓                                              │
│      part_category (속도 중요)                            │
└─────────────────────────────────────────────────────────┘
```

### 성능 요구사항
- **검출 속도**: < 100ms/frame (실시간)
- **정확도**: Top-1 > 97% (SLO 기준)
- **오프라인**: 인터넷 없이 작동
- **확장성**: 분기별 신제품 대응

---

## 🎯 권장 전략: **하이브리드 (고정 + 로그 기반 확장)**

### Phase 1: 기본 고정 카테고리 (현재)
✅ **30개 고정 카테고리 사용**
- 레고 부품 형태 99% 커버
- 폐쇄환경 안정 운영
- 검출 속도 최적화 (고정 매핑)

```javascript
// 현재 구현 (고정 30개)
const CATEGORIES = {
  'plate': 1, 'brick': 2, 'tile': 3, 'slope': 4,
  'panel': 5, 'wedge': 6, 'cylinder': 7, 'cone': 8,
  'arch': 9, 'round': 10, 'dish': 11, 'hinge': 12,
  'clip': 13, 'bar': 14, 'fence': 15, 'door': 16,
  'window': 17, 'roof': 18, 'inverted': 19,
  'minifig_part': 20, 'animal_figure': 21, 'plant_leaf': 22,
  'wheel': 23, 'tire': 24, 'wing': 25, 'propeller': 26,
  'gear': 27, 'chain': 28, 'axle': 29,
  'unknown': 99
};
```

### Phase 2: 로그 기반 확장 (분기별)
✅ **주기적 분석 + 수동 추가**

```
운영 중 → unknown(99) 로그 수집 → 분석 (분기 1회)
         ↓
      새로운 형태 패턴 발견
         ↓
      수동 카테고리 추가 (SQL INSERT)
         ↓
      폐쇄환경 DB 업데이트 (USB/네트워크)
```

**장점:**
- ✅ 실시간 성능 유지 (고정 매핑)
- ✅ 폐쇄환경 안정성
- ✅ 제어된 확장 (품질 보증)
- ✅ 분기 1회 업데이트로 충분

---

## 🚫 자동 확장을 권장하지 않는 이유

### 1. 폐쇄환경 제약
```
❌ 인터넷 없음 → DB 실시간 업데이트 어려움
❌ pending_categories 테이블 동기화 문제
❌ 자동 승인 로직이 오프라인에서 작동 안함
```

### 2. 검출 속도 저하
```
고정 매핑: O(1) 해시 조회 → ~0.001ms
동적 로딩: DB 쿼리 + 캐시 → ~10-50ms
→ 실시간 검출 시 병목 가능성
```

### 3. 품질 리스크
```
자동 확장 → 노이즈 카테고리 생성 가능
→ LLM 오분석 → 잘못된 카테고리 추가
→ 검수 시스템 정확도 저하
```

### 4. 복잡도 증가
```
고정 시스템: 간단, 안정적
자동 확장: pending 테이블, 승인 로직, 동기화 → 관리 부담
```

---

## ✅ 권장 구현 방식

### 1. 현재 상태 유지 (고정 30개)
```sql
-- ✅ 실행: 기본 3개 SQL만
psql -f database/create_part_categories_table.sql
psql -f database/fix_part_category_constraint.sql
psql -f database/migrate_part_categories.sql
```

### 2. unknown 로그 수집 추가
```javascript
// src/composables/useMasterPartsPreprocessing.js

function getPartCategoryCodeSync(shapeTag) {
  const mapping = getHardcodedCategoryMapping();
  const categoryId = mapping[shapeTag];
  
  // ✅ unknown 로그 수집 (분석용)
  if (!categoryId || categoryId === 99) {
    logUnknownCategory({
      shape_tag: shapeTag,
      timestamp: new Date().toISOString(),
      part_id: context?.part_id,
      part_name: context?.part_name
    });
  }
  
  return categoryId || 99;
}

// ✅ 로그 수집 함수
async function logUnknownCategory(data) {
  try {
    // 로컬 로그 파일 또는 별도 테이블에 저장
    await supabase
      .from('unknown_category_logs')
      .insert({
        shape_tag: data.shape_tag,
        part_id: data.part_id,
        part_name: data.part_name,
        detected_at: data.timestamp
      });
  } catch (err) {
    // 오프라인 시 로컬 파일로 폴백
    console.warn('Unknown category:', data);
  }
}
```

### 3. 로그 분석 테이블 (선택)
```sql
-- database/create_unknown_category_logs.sql

CREATE TABLE IF NOT EXISTS unknown_category_logs (
  id SERIAL PRIMARY KEY,
  shape_tag VARCHAR(50),
  part_id VARCHAR(20),
  part_name VARCHAR(255),
  detected_at TIMESTAMP DEFAULT NOW(),
  occurrence_count INTEGER DEFAULT 1
);

-- 집계 뷰
CREATE OR REPLACE VIEW v_unknown_categories_summary AS
SELECT 
  shape_tag,
  COUNT(*) as occurrence_count,
  COUNT(DISTINCT part_id) as unique_parts,
  MIN(detected_at) as first_seen,
  MAX(detected_at) as last_seen
FROM unknown_category_logs
GROUP BY shape_tag
HAVING COUNT(*) >= 5  -- 5회 이상 발견된 것만
ORDER BY occurrence_count DESC;
```

### 4. 분기별 카테고리 추가 프로세스
```sql
-- 분기 1회 실행 (신규 카테고리 추가)

-- 1. 로그 분석
SELECT * FROM v_unknown_categories_summary;

-- 2. 검토 후 추가 (예: 'connector')
INSERT INTO part_categories (id, code, display_name, display_name_ko, category_type, sort_order)
VALUES (30, 'connector', 'Connector', '커넥터', 'shape', 30);

-- 3. 기존 데이터 마이그레이션
UPDATE parts_master_features
SET part_category = 30, shape_tag = 'connector'
WHERE shape_tag = 'unknown' 
  AND LOWER(part_name) LIKE '%connector%';

-- 4. 로그 정리
DELETE FROM unknown_category_logs WHERE shape_tag = 'connector';
```

---

## 📊 비교표: 자동 vs 로그 기반

| 항목 | 자동 확장 | 로그 기반 확장 (권장) |
|------|-----------|---------------------|
| **검출 속도** | ⚠️ 느림 (DB 쿼리) | ✅ 빠름 (고정 매핑) |
| **폐쇄환경** | ❌ 제한적 | ✅ 완벽 지원 |
| **품질 관리** | ⚠️ 노이즈 가능 | ✅ 수동 검증 |
| **복잡도** | ❌ 높음 | ✅ 낮음 |
| **확장성** | ✅ 실시간 | ✅ 분기별 (충분) |
| **유지보수** | ⚠️ 복잡 | ✅ 간단 |
| **안정성** | ⚠️ 변동 가능 | ✅ 안정적 |

---

## 🎯 최종 권장사항

### ✅ **로그 기반 확장 전략 선택**

**이유:**
1. **실시간 성능 보장** - 고정 매핑으로 검출 속도 최적화
2. **폐쇄환경 완벽 지원** - 오프라인 운영 안정성
3. **품질 관리** - 수동 검증으로 정확도 유지
4. **충분한 확장성** - 분기 1회 업데이트로 신제품 대응
5. **낮은 복잡도** - 관리 부담 최소화

### 📋 실행 체크리스트

**즉시 실행:**
- [x] 기본 3개 SQL 실행 (고정 30개 카테고리)
- [ ] `unknown_category_logs` 테이블 생성 (선택)
- [ ] 로그 수집 코드 추가 (선택)

**분기별 작업:**
- [ ] unknown 로그 분석
- [ ] 신규 카테고리 검토
- [ ] 수동 추가 (SQL INSERT)
- [ ] 폐쇄환경 DB 업데이트

**자동 확장 시스템:**
- [ ] ❌ **설치하지 않음** (복잡도 증가, 폐쇄환경 부적합)

---

## 💡 추가 최적화 제안

### 1. 혼동 부품 처리 강화
```javascript
// confusion_matrix 기반 후처리
// 비슷한 부품들 (2x2 plate vs 2x2 tile) 구분 강화
if (detectedCategory === 1) {  // plate
  // stud_count_top으로 tile 여부 재검증
  if (studCount === 0) {
    detectedCategory = 3;  // tile로 재분류
  }
}
```

### 2. 부품별 신뢰도 가중치
```javascript
// 자주 검출되는 부품 우선순위
const categoryConfidence = {
  1: 0.95,  // plate - 높음
  2: 0.93,  // brick - 높음
  21: 0.70, // animal_figure - 낮음 (희귀)
  99: 0.50  // unknown - 매우 낮음
};
```

### 3. BOM 기반 사전 필터링
```javascript
// 세트 BOM에 없는 카테고리는 제외
const allowedCategories = getBOMCategories(setId);
if (!allowedCategories.includes(detectedCategory)) {
  // 재검토 또는 경고
}
```

---

## 📈 예상 효과

### 성능
- ✅ 검출 속도: < 100ms/frame 유지
- ✅ 정확도: > 97% (SLO 달성)
- ✅ 오프라인 안정성: 100%

### 운영
- ✅ 분기 1회 업데이트 (30분 작업)
- ✅ 관리 복잡도: 낮음
- ✅ 품질 일관성: 높음

### 확장성
- ✅ 30개 → 50개 (5년 내 충분)
- ✅ 신제품 대응: 분기별
- ✅ 특수 세트 대응: 커스텀 카테고리 추가 가능

---

**결론**: **고정 카테고리 + 로그 기반 확장** 전략 강력 추천!

자동 확장은 온라인 서비스나 클라우드 환경에서는 유용하지만,  
폐쇄환경 + 실시간 검출 시스템에서는 **오버엔지니어링**입니다.

**지금 바로 기본 SQL 3개만 실행하세요!** 🚀

