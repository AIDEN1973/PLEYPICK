# 🔍 BrickBox 시스템 전체 분석 및 최적화 계획

**작성일**: 2025-10-13  
**범위**: New Lego Registration 전체 플로우

---

## 📊 1. 현재 플로우 분석

### 🔄 전체 프로세스
```
1. 세트 검색 및 선택
   ↓
2. 부품 정보 로드 (Rebrickable API)
   ↓
3. 중복 세트 확인
   ↓
4. 배치 DB 저장 (set → parts → colors → relationships)
   ↓
5. 이미지 마이그레이션 트리거
   ↓
6. 마이그레이션 완료 대기 ⚠️ (최대 2분)
   ↓
7. LLM 분석 시작 (백그라운드)
```

---

## 🐌 2. 병목 지점 분석

### ⚠️ 심각한 병목 (High Priority)

#### 1. **이미지 마이그레이션 대기**
**위치**: `NewLegoRegistration.vue:1512-1534`
```javascript
// 폴링 방식으로 마이그레이션 완료 대기 (최대 2분)
const migrationComplete = await waitForMigrationComplete(
  selectedSet.value.set_num,
  120000, // ⚠️ 최대 2분 블로킹!
  2000    // 2초마다 폴링
)
```
**문제점**:
- UI가 2분간 블로킹
- 불필요한 대기 (LLM 분석은 원본 이미지로도 가능)
- 2초마다 DB 쿼리 (리소스 낭비)

**예상 시간 절감**: ~60-120초

---

#### 2. **이미지 검증 지연**
**위치**: `useMasterPartsPreprocessing.js:623-653`
```javascript
// 이미지 URL 검증 (최대 2회 재시도)
for (let verifyAttempt = 1; verifyAttempt <= 2; verifyAttempt++) {
  const verifyResponse = await fetch(llmImageUrl, { 
    method: 'HEAD',
    signal: AbortSignal.timeout(3000) // ⚠️ 3초 타임아웃
  })
  
  if (verifyAttempt < 2) {
    await new Promise(resolve => setTimeout(resolve, 2000)) // ⚠️ 2초 대기
  }
}
```
**문제점**:
- 각 이미지당 최대 8초 (3+2+3초)
- 10개 부품 = 80초 추가 지연
- 방금 전 수정으로 인한 새로운 병목

**예상 시간 절감**: ~40-80초

---

#### 3. **업로드 검증 지연**
**위치**: `useImageManager.js:256-277`
```javascript
// 업로드 검증 (최대 3회 재시도)
for (let attempt = 1; attempt <= 3; attempt++) {
  const verifyResponse = await fetch(publicUrl, { method: 'HEAD' })
  if (verifyResponse.ok) {
    verified = true
    break
  }
  await new Promise(resolve => setTimeout(resolve, 1000 * attempt)) // 1초, 2초, 3초
}
```
**문제점**:
- 각 업로드당 최대 6초 (1+2+3초)
- 10개 이미지 = 60초 추가

**예상 시간 절감**: ~30-60초

---

### ⚠️ 중간 병목 (Medium Priority)

#### 4. **순차적 이미지 마이그레이션**
**위치**: `useAutoImageMigration.js`
```javascript
// 워커 기반 병렬 처리이지만 배치 간 대기 존재
for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
  // ...
  if (batchIndex < batches.length - 1) {
    await new Promise(resolve => setTimeout(resolve, 500))
  }
}
```
**예상 시간 절감**: ~5-10초

---

#### 5. **기존 관계 조회**
**위치**: `useBatchProcessing.js:112-128`
```javascript
const { data: existingRelations } = await supabase
  .from('set_parts')
  .select('part_id, color_id, quantity, is_spare, element_id, inv_part_id')
  .eq('set_id', savedSet.id)
```
**문제점**:
- 불필요한 추가 DB 쿼리 (upsert로 대체 가능)

**예상 시간 절감**: ~1-2초

---

### ✅ 잘 최적화된 부분

1. **배치 DB 저장** ✅
   - 부품/색상 배치 upsert
   - 중복 제거 로직

2. **병렬 이미지 처리** ✅
   - 10개씩 배치 처리
   - Promise.allSettled 사용

3. **LLM 배치 분석** ✅
   - 10개씩 병렬 처리
   - 재시도 로직

---

## 🚀 3. 최적화 계획

### Priority 1: 마이그레이션 대기 제거 ⭐⭐⭐
**목표**: UI 블로킹 제거

**방법**:
```javascript
// ❌ 현재 (동기)
const migrationComplete = await waitForMigrationComplete(...)
const taskId = await startBackgroundAnalysis(...)

// ✅ 개선 (비동기)
// 마이그레이션과 LLM 분석을 동시에 시작
const [migrationPromise, llmTaskId] = await Promise.all([
  triggerFullMigration(),
  startBackgroundAnalysis(selectedSet.value, setParts.value)
])
```

**예상 효과**:
- 60-120초 절감
- 사용자 경험 개선

---

### Priority 2: 이미지 검증 최적화 ⭐⭐⭐
**목표**: 검증 시간 단축

**방법 1**: 타임아웃 단축
```javascript
// ❌ 현재
signal: AbortSignal.timeout(3000) // 3초
await new Promise(resolve => setTimeout(resolve, 2000)) // 2초

// ✅ 개선
signal: AbortSignal.timeout(1000) // 1초
await new Promise(resolve => setTimeout(resolve, 500)) // 0.5초
```

**방법 2**: 검증 병렬화
```javascript
// 모든 이미지 검증을 병렬로 실행
const verifyPromises = images.map(img => 
  fetch(img.url, { method: 'HEAD', signal: AbortSignal.timeout(1000) })
)
await Promise.allSettled(verifyPromises)
```

**예상 효과**:
- 40-80초 절감
- API 호출 안정성 유지

---

### Priority 3: 업로드 검증 조건부 실행 ⭐⭐
**목표**: 불필요한 검증 제거

**방법**:
```javascript
// ✅ 개선: 첫 업로드만 검증
if (isFirstUpload || import.meta.env.DEV) {
  // 검증 실행
}
```

**예상 효과**:
- 30-60초 절감

---

### Priority 4: 데이터베이스 쿼리 최적화 ⭐
**목표**: 불필요한 쿼리 제거

**방법**:
```javascript
// ❌ 현재: 기존 관계 조회 후 중복 체크
const { data: existingRelations } = await supabase
  .from('set_parts')
  .select(...)
  .eq('set_id', savedSet.id)

// ✅ 개선: upsert로 직접 처리
await supabase
  .from('set_parts')
  .upsert(setPartsToInsert, { 
    onConflict: 'set_id,part_id,color_id',
    ignoreDuplicates: false 
  })
```

**예상 효과**:
- 1-2초 절감
- 코드 간소화

---

## 📈 4. 예상 성능 개선

### 현재 소요 시간 (10개 부품 기준)
```
1. DB 저장: ~3초
2. 이미지 업로드 검증: ~30초
3. 마이그레이션 대기: ~60초
4. 이미지 URL 검증: ~40초
5. LLM 분석 시작: ~2초
---
총 소요 시간: ~135초 (2분 15초)
```

### 최적화 후 예상 시간
```
1. DB 저장: ~2초 (최적화)
2. 이미지 업로드 (검증 제거): ~10초
3. 마이그레이션 (비동기): ~0초 (블로킹 제거)
4. 이미지 URL 검증 (병렬화): ~5초
5. LLM 분석 시작: ~1초
---
총 소요 시간: ~18초 (90% 개선!) 🚀
```

---

## 🎯 5. 실행 계획

### Phase 1: 긴급 최적화 (즉시 적용)
- [ ] 마이그레이션 대기 제거
- [ ] 이미지 검증 타임아웃 단축
- [ ] 업로드 검증 조건부 실행

### Phase 2: 구조 개선 (단기)
- [ ] 이미지 검증 병렬화
- [ ] DB 쿼리 최적화
- [ ] 캐싱 강화

### Phase 3: 장기 개선
- [ ] WebWorker 활용
- [ ] IndexedDB 캐싱
- [ ] Progressive 이미지 로딩

---

## ✅ 6. 성공 지표

1. **속도**: 135초 → 18초 (87% 개선)
2. **사용자 경험**: UI 블로킹 제거
3. **안정성**: OpenAI API 성공률 95% 유지
4. **리소스**: DB 쿼리 20% 감소

---

## 📝 다음 단계

1. Phase 1 최적화 즉시 적용
2. 성능 측정 및 모니터링
3. 사용자 피드백 수집
4. Phase 2/3 단계적 적용

